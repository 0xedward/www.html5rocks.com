{% extends "tutorial.html" %}

{% block headtitle %}자바스크립트 성능 미스터리를 해결하기위해 과학수사 및 탐정수사를 사용하세요{% endblock %}
{% block pagetitle %}자바스크립트 성능 미스터리를 해결하기위해 과학수사 및 탐정수사를 사용하세요{% endblock %}

{% block head %}
{% endblock %}

{% block content %}
<h2 id="toc-introduction" >서문</h2>
<p ><span></span></p>
<p ><span>최근 몇 년 동안, 웹 어플리케이션들은 상당히 속도를 내어 왔습니다. 제가 몇몇 개발 자들이 &ldquo;이 웹은 충분히 빠른가요?&rdquo;라고 큰소리로 걱정하는 것을 들을 만큼 이제 많은 어플리케이션은 충분히 빠르게 동작합니다. 일부 어플리케이션에 대해서는 그럴 수 있지만, 고성능 어플리케이션을 작업 중인 개발자들에 대해 우리는 이것이 충분히 빠르지 않다는 것을 알고 있습니다. 자바스크립트 가상 머신 기술의 놀라운 진보에도 불구하고 <a  href="https://docs.google.com/a/google.com/document/d/1k8d4SsYJoCfmw6Te8Ijf3WEyotNHp6YMy1PEgn_o5Yg/edit">최근 한 연구</a>는 Google 어플리케이션이 그들의 시간 중 50~80%를 <a  href="https://code.google.com/p/v8/">V8</a>에서 보내고 있음을 증명 하였습니다. 여러분의 어플리케이션은 한정된 시간의 양을 가지고 있고, 한 시스템의 사이클을 줄이는 것은 또 다른 시스템이 더 일할 수 있음을 뜻합니다. 기억하세요, 60fps로 구동되는 어플리케이션은 프레임 당 16ms를 가지거나 그렇지 않으면 &mdash; <a href="http://jankfree.org">jank</a>를 가집니다.&nbsp;<a  href="http://www.findyourwaytooz.com/">Find Your Way to Oz</a>&nbsp;사이트의 모호한 성능 문제를 찾아내는 V8 팀 소속 성능 탐정들의 참호 이야기에서 자바스크립트를 최적화하는 것에 대해 배우고 자바스크립트 어플리케이션을 프로파일링 하기 위해 계속 읽어 보세요.</span></p>
<p ><span></span></p>
<h2 id="toc-watch-the-movie">Google I/O 2013 Session</h2>

<p>저는 이 소재를 Google I/O 2013 에서 발표했습니다. 아래 비디오를 확인해 보세요:</p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/VhpdsjBUS3g" frameborder="0" allowfullscreen></iframe>

<h2 id="toc-why-performance-matters" >왜 성능이 중요할까요?</h2>

<p ><span>CPU 사이클은 하나의 제로-썸 게임입니다. 여러분 시스템의 일부가 더 적게 사용하도록 만드는 것은 여러분이 또다른 시스템에서 더 사용할 수 있게 하거나 혹은 전반적으로 더 부드럽게 구동하게 해줍니다. 빠르게 동작하는 것과 좀더 일하는 것은 흔히 상충되는 목표입니다. 사용자들은 새로운 기능들을 요구하는 한편 여러분의 어플리케이션이 부드럽게 동작하는 것 또한 기대합니다. 자바스크립트 가상 머신은 계속 빨라지고 있지만, 그것은 자신들의 웹 어플리케이션 안에 이미 알고 있는 성능 문제를 다루고 있는 많은 개발자들 처럼 여러분이 오늘 고칠 수 있는 성능 문제들을 무시하는 것에 대한 이유는 아닙니다. 실시간, 높은 프레임 속도의 어플리케이션에서 jank 프리가 되어야 한다는 부담은 무엇 보다 중요합니다. <a  href="http://www.insomniacgames.com/">Insomniac Games</a>는 끊임 없이 일관된 프레임 속도는 한 게임의 성공에 매우 중요하다는 것을 보여 준 한 <a  href="http://www.eurogamer.net/articles/insomniac-60fps-no-more">연구</a>: &ldquo;끊임 없는 프레임 속도는 여전히 전문적이고 잘 만든 제품의 표식이다(A solid frame-rate is still a sign of professional, well-made product).&rdquo; 를 제작했습니다. 웹 개발자분들은 주목해 주세요.</span></p>
<h2 id="toc-solving-performance-problems" >성능 문제 해결하기</h2>
<p ><span></span></p>
<p ><span>성능 문제를 해결하는 것은 범죄를 해결하는 것과 유사합니다. 여러분은 조심스럽게 증거를 조사하고 의심되는 원인들을 확인하고 다른 해결책들을 실험하는 것이 필요합니다. 이러한 과정 내내 여러분은 문제를 실제로 수정 했는 지 확인할 수 있도록 반드시 여러분의 측정을 문서화 해야 합니다. 이 방법과 어떻게 범죄 수사관들이 사건을 해결하는 지 사이에는 아주 작은 차이점이 있습니다. 수사관들은 증거를 조사하고 용의자를 심문하고 명백한 증거를 찾기를 희망하며 실험을 실시합니다.</span></p>
<p ><span></span></p>
<h2 id="toc-v8-csi" >V8 CSI: 오즈</h2>
<p ><span></span></p>
<p ><span>놀라운 마법사 빌딩 <a href="http://www.findyourwaytooz.com/">Find Your Way to Oz</a> 는 그들 스스로 해결할 수 없는 성능 문제를 가지고 V8팀에 다가왔습니다. 가끔 오즈는 멈추거나 jank가 일어납니다. 오즈 개발자들은 <a  href="https://developers.google.com/chrome-developer-tools/">Chrome DevTools</a>의 <a  href="https://developers.google.com/chrome-developer-tools/docs/timeline">Timeline Panel</a>을 이용해 몇 가지 초기 검사를 완료했습니다. 메모리 사용량을 관찰해 보면 그들은 두려운 <a  href="http://en.wikipedia.org/wiki/Sawtooth_wave">톱날</a> 그래프에 맞닥뜨렸습니다. 초당 한번 가비지 컬렉터는 가비지 10MB를 수집하고 있었고 가비지 컬렉션은 jank에 상응하여 정지했습니다. 다음 Chrome Devtools의 Timeline 스크린샷과 유사합니다:</span></p>

<p>
<figure>
<img height="81" src="images/image01.png">
</figure>
</p>

<p ><span>V8 수사관 제이콥과 양은 이 사건을 맡았습니다. 발생 일은 V8 팀과 오즈 팀으로 부터 제이콥과 양 사이의 긴 논쟁이었습니다. 저는 이 대화를 이 문제를 찾는 것을 도운 중요한 사건들로 정제했습니다.</span></p>

<h2 id="toc-evidence" >증거</h2>

<p ><span>첫 단계는 초기 증거를 수집하고 연구하는 것입니다. </span></p>
<p ><span></span></p>
<h3 id="toc-application-type" >우리가 보고있는 것은 어떤 종류의 어플리케이션 일까요?</h3>
<p ><span></span></p>
<p ><span>오즈 데모는 인터렉티브 3D 어플리케이션입니다. &nbsp;그렇게 때문에 가비지 컬렉션에 의해 발생하는 멈춤에 매우 민감합니다. 기억하세요, 60fps로 동작하는 인터렉티브 어플리케이션은 <a href="http://www.html5rocks.com/en/tutorials/speed/rendering/">모든 자바스크립트 작업을 수행하는 데 16ms를 쓰고 반드시 그 시간 중 일부를 크롬이 그래픽 호출을 처리하고 화면에 그리기 위해 남겨두어야 합니다.</a>.</span></p>
<p ><span></span></p>
<p ><span>오즈는 double 값으로 수 많은 연산을 수행하고 WebAudio와 WebGL을 빈번히 호출합니다.</span></p>
<h3 id="toc-performance-problem" ><span>우리가 보고 있는 것은 어떤 종류의 성능 문제일까요?</span></h3>
<p ><span></span></p>
<p ><span>우리는 jank라고도 알려지고 프레임 감소라고도 알려진 멈춤을 보고있습니다. 이러한 멈춤들은 가비지 컬렉션 실행과 상관관계를 가집니다.</span></p>
<h3 id="toc-best-practices" ><span>그 개발자들은 좋은 관행을 따르고 있습니까?</span></h3>
<p ><span></span></p>
<p ><span>그렇습니다, 오즈 개발자들은 자바스크립트 VM 성능과 최적화 테크닉에 잘 숙달되어있습니다. 오즈 개발자들이 그들의 소스 언어로 <a  href="http://coffeescript.org/">CoffeeScript</a>를 사용했던 것과 CoffeeScript 컴파일러로 자바스크립트를 생성했던 것은 아무런 가치가 없습니다. 오즈 개발자들에 의해 쓰여졌던 코드와 V8에 의해 소비 되는 코드 사이의 단절로 인해 이것은 일부 검사를 더 까다롭게 만듭니다. 이제 크롬 DevTools은 이것을 쉽게 해주는 <a  href="http://net.tutsplus.com/tutorials/tools-and-tips/source-maps-101/">source maps</a>을 지원합니다.</span></p>
<h3 id="toc-why-does-gc-run" ><span>가비지 컬렉터는 왜 실핼할까요?</span></h3>
<p ><span></span></p>
<p ><span>자바스크립트 안에서 메모리는 개발자들을 위해 VM으로 자동 관리됩니다. V8은 메모리가 둘(또는 그 이상)의 <a  href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Generational_GC_.28ephemeral_GC.29">세대</a>로 나뉘어 지는 곳에 공통적인 가비지 컬렉션 시스템을 사용합니다. 젊은 세대는 최근 할당된 객체를 들고 있습니다. 만약 한 객체가 충분히 오래 살아있다면, 이것은 늙은 세대로 옮겨집니다.</span></p>
<p ><span></span></p>
<p ><span>젊은 세대는 늙은 세대가 수집되는 것 보다 더 높은 빈도로 수집됩니다. 이것은 계획적인 것이고, 젊은 세대 수집은 좀 더 비용이 적게 듭니다. 빈번한 GC 멈춤이 젊은 세대 수집에 의해 발생된다고 추정하는 보통 안전합니다.</span></p>
<p ><span></span></p>
<p ><span>V8에서 신생의 메모리 공간은 두 개의 크기가 동일한 연속 메모리 블럭으로 나뉘어 집니다. 이 두 개의 메모리 블럭 중 오직 하나만 어떤 주어진 시간에 사용되고 이는 공간이라고 불립니다. 이 공간에 메모리가 남아 있는 동안 새로운 객체를 할당하는 것은 적은 비용이 듭니다. 이 공간에서의 커서는 새 객체를 위해 필요한 바이트 수 만큼 앞으로 옮겨집니다. 이것은 공간이 고갈 될 때 까지 계속됩니다. 이 부분에서 프로그램은 멈추고 수집은 시작합니다.</span></p>
<p >
<figure>
<img height="290" src="images/image05.png">
</figure>
</p>
<p ><span>이 시점에서 출발 공간과 도착 공간이 스왑됩니다. 도착 공간이었던 것 그리고 이제 출발 공간인 것, 시작부터 끝까지 스캔된 것과 여전히 살아있는 모든 객체들은 도착 공간으로 복사되거나 또는 늙은 세대 힙으로 진급됩니다. 더 상세히 알고 싶으시면 <a  href="http://en.wikipedia.org/wiki/Cheney&#39;s_algorithm">체니의 알고리즘</a>에 대해 읽어 볼 것을 추천합니다.</span></p>
<p ><span></span></p>
<p ><span>직관적으로 여러분은 객체가 암시적이거나 또는 명시적으로(new, [] 또는 {}를 호출하는 것에 의해) 할당 될 때 마다 여러분의 어플리케이션이 가비지 컬렉터와 두려운 어플리케이션 멈춤에 점점 더 다가가는 것을 알아야 합니다.</span></p>
<h3 id="toc-is-this-normal" ><span>이 어플리케이션에 대해 초 당 10MB의 가비지가 예상되나요?</span></h3>
<p ><span></span></p>
<p ><span>요컨대, 아닙니다. 이 개발자는 초 당 10MB의 가비지를 예상하기 위한 그 어떤 것도 하고 있지 않습니다.</span></p>
<h2 id="toc-suspects" >용의자들</h2>
<p ><span></span></p>
<p ><span>조사의 다음 단계는 잠재적 용의자들을 결정하고 그들을 줄이는 것입니다.</span></p>
<h3 id="toc-suspect-1" ><span>용의자 #1</span></h3>
<p ><span></span></p>
<p ><span>프레임에 new를 호출을 하는 것. 할당 된 각 객체는 여러분을 GC 멈춤으로 가장 가깝게 이동시킨다는 것을 기억하세요. 특히 높은 프레임 속도로 동작 중인 어플리케이션은 프레임 당 할당 제로를 위해 노력해야 합니다. 보통 이것은 어플리케이션 특정적인 어플리케이션 객체 재사용 시스템을 조심스레 심사숙고하는 것을 필요로합니다. V8 수사관들은 오즈 팀과 함께 점검했고 그들은 new를 호출하고 있지 않았습니다. 사실 오즈 팀은 이미 이것의 필요성을 잘 인지하고 있었고 &ldquo;그건 당황스러운 것 같네요&rdquo;라고 말했습니다. 이 용의자는 리스트에서 지우세요.</span></p>
<h3 id="toc-suspect-2" ><span>용의자 #2</span></h3>
<p ><span></span></p>
<p ><span>Modifying the &ldquo;shape&rdquo; of an object outside of the constructor. This happens whenever a new property is added to an object outside of the constructor. &nbsp;This creates a new </span><span ><a  href="https://developers.google.com/v8/design">hidden class</a></span><span>&nbsp;for the object. When optimized code sees this new hidden class a deopt will be triggered, unoptimized code will execute until the code is classified as hot and optimized again. This de-optimization,re-optimization churn will result in jank but does not strictly correlate with excessive garbage creation. After a careful audit of the code, it was confirmed that object shapes were static, thus suspect #2 was ruled out.</span></p>
<p ><span></span></p>
<h3 id="toc-suspect-3" ><span>Suspect #3</span></h3>
<p ><span></span></p>
<p ><span>Arithmetic in unoptimized code. In unoptimized code all computation results in actual objects being allocated. For example, this snippet:</span></p>
<p ><span></span></p>
<pre class="prettyprint">
var a = p * d;
var b = c + 3;
var c = 3.3 * dt;
point.x = a * b * c;
</pre>
<p ><span>Results in 5 HeapNumber objects being created. The first three are for the variables, a, b, and c. The 4th is for the anonymous value (a * b) and the 5th is from #4 * c; The 5th is ultimately assigned to point.x.</span></p>
<p ><span></span></p>
<p ><span>Oz does thousands of these operations per frame. If any of these computations </span><span>occur</span><span>&nbsp;in functions which are never optimized, they could be the cause of the garbage.</span> Because computations in unoptimized allocate
memory even for temporary results.</p>
<h3 id="toc-suspect-4" ><span>Suspect #4</span></h3>
<p ><span></span></p>
<p ><span>Storing a double precision number to a property. A HeapNumber object must be created to store the number and the property altered to point at this new object. Altering the property to point at the HeapNumber will not produce garbage. However, it is possible that there are many double precision numbers being stored as object properties. The code is full of statements like the following:</span></p>
<pre class="prettyprint">
    sprite.position.x += 0.5 * (dt);
</pre>
<p ><span>In optimized code, every time </span><span>x is </span><span>assigned a freshly computed value, a seemingly innocuous statement, a new HeapNumber object is implicitly allocated, bringing us closer to a garbage collection pause. </span></p>
<p ><span></span></p>
<p ><span>Note that by using a </span><span ><a  href="http://www.khronos.org/registry/typedarray/specs/latest/">typed array</a></span><span>&nbsp;(or a regular array which only has held doubles)</span><span>&nbsp;you can avoid this specific problem entirely as the storage for the double precision number is allocated only once and repeatedly changing the value does not require new storage to be allocated.</span></p>
<p ><span></span></p>
<p ><span>Suspect #4 is a possibility. </span></p>
<p ><span></span></p>
<h2 id="toc-forensics" >Forensics</h2>
<p ><span></span></p>
<p ><span>At this point the detectives have two possible suspects: storing heap numbers as object properties and arithmetic computation happening inside unoptimized functions. It was time to head to the lab and determine definitively which suspect was guilty. NOTE: In this section I will be using a reproduction of the problem found in the actual Oz source code. This reproduction is orders of magnitude smaller than the original code, thus easier to reason about.</span></p>
<h3 id="toc-experiment-1" ><span>Experiment #1</span></h3>
<p ><span></span></p>
<p ><span>Checking for suspect #3 (arithmetic computation inside unoptimized functions). The V8 JavaScript engine has a logging system builtin which can provide great insight into what is happening under the hood.</span></p>
<p ><span></span></p>
<p ><span>Starting with Chrome not running at all, launching Chrome with the flags:
<pre class="prettyprint">
--no-sandbox --js-flags="--prof --noprof-lazy --log-timer-events"
</pre>
and then fully quitting Chrome will result in a </span><span >v8.log</span><span>&nbsp;file in the current directory.</span></p>
<p ><span></span></p>
<p ><span>In order to interpret the contents of </span><span >v8.log</span><span>, you must </span><span ><a  href="https://code.google.com/p/v8/wiki/Source">download</a></span><span>&nbsp;the same version of v8 that your Chrome is using (check </span><span >about:version</span><span>), and </span><span ><a  href="https://developers.google.com/v8/build">build it</a></span><span>.</span></p>
<p ><span></span></p>
<p ><span>After successfully building v8, you can process the log using the tick processor:</span></p>
<p ><span></span></p>
<pre class="prettyprint">
$ tools/linux-tick-processor /path/to/v8.log
</pre>
<p ><span></span></p>
<p ><span>(Substitute mac or windows for linux depending on your platform.)</span></p>
<p ><span>(This tool must be run from the top level source directory in v8.)</span></p>
<p ><span></span></p>
<p ><span>The tick processor displays a text based table of JavaScript functions which had the most ticks:</span></p>
<p ><span></span></p>
<pre class="prettyprint">
[JavaScript]:</span></p>
ticks  total  nonlib   name
167   61.2%   61.2%  LazyCompile: *opt demo.js:12
 40   14.7%   14.7%  LazyCompile: unopt demo.js:20
 15    5.5%    5.5%  Stub: KeyedLoadElementStub
 13    4.8%    4.8%  Stub: BinaryOpStub_MUL_Alloc_Number+Smi
  6    2.2%    2.2%  Stub: BinaryOpStub_ADD_OverwriteRight_Number+Number
  4    1.5%    1.5%  Stub: KeyedStoreElementStub
  4    1.5%    1.5%  KeyedLoadIC:  {12}
  2    0.7%    0.7%  KeyedStoreIC:  {13}
  1    0.4%    0.4%  LazyCompile: ~main demo.js:30
</pre>
<p ><span></span></p>
<p ><span>You can see demo.js had three functions: opt, unopt, and main. Optimized functions have an asterisk (*) next to their names. Observe that the function opt is optimized and unopt is unoptimized. </span></p>
<p ><span></span></p>
<p ><span>Another important tool in the V8 detective&rsquo;s tool bag is plot-timer-event. It can be executed like so:</span></p>
<pre class="prettyprint">
$ tools/plot-timer-event /path/to/v8.log
</pre>
<p ><span>After being run, a png file called timer-events.png is in the current directory. Opening it up you should see something that looks like this:</span></p>
<p ><span></span></p>
<p >
<figure>
<img height="260" src="images/image04.png">
</figure>
</p>
<p ><span></span></p>
<p ><span>Aside from the graph along the bottom, data is displayed in rows. The X axis is time (ms). The left hand side includes labels for each row:</span></p>
<p ><span></span></p>
<p >
<figure>
<img height="309" src="images/image02.png">
</figure>
</p>
<p ><span></span></p>
<p ><span>The V8.Execute row has black vertical line drawn on it at each profile tick where V8 was executing JavaScript code. V8.GCScavenger has a blue vertical line drawn on it at each profile tick where V8 was performing a </span><span >new</span><span>&nbsp;generation collection. Similarly for the rest of the V8 states.</span></p>
<p ><span></span></p>
<p ><span>One of the most important rows is the &ldquo;code kind being executed&rdquo;. It will be green whenever optimized code is executing and mix of red and blue when unoptimized code is being executed. The following screenshot shows the transition from optimized to unoptimized and then back to optimized code:</span></p>
<p ><span></span></p>
<p >
<figure>
<img height="43" src="images/image03.png">
</figure>
</p>
<p ><span></span></p>
<p ><span>Ideally, but never immediately, this line will be solid green. Meaning that your program has transitioned into an optimized steady state. Unoptimized code will always run slower than optimized code.</span></p>
<p ><span></span></p>
<p ><span>If you&rsquo;ve gone to this length it&rsquo;s worth noting that you can work much quicker by refactoring your application so that it can run in the v8 debug shell: </span><span >d8</span><span>. Using d8 gives you faster iteration times with the tick-processor and plot-timer-event tools. Another side effect of using d8 is that it becomes easier to isolate actual problem, reducing the amount of noise present in the data.</span></p>
<p ><span></span></p>
<p ><span>Looking at the timer events plot from the Oz source code, showed a transition from optimized to unoptimized code and, while executing unoptimized code many </span><span >new</span><span>&nbsp;generation collections were </span><span>trigger</span><span>ed, similar to the following screenshot (</span><span>note time has been removed in the middle</span><span>):</span></p>
<p ><span></span></p>
<p >
<figure>
<img height="325" src="images/image00.png">
</figure>
</p>
<p ><span></span></p>
<p ><span>If you look closely you can see that the black lines indicating when V8 is executing JavaScript code are missing at precisely the same profile tick times as the </span><span >new</span><span>&nbsp;generation collections (blue lines). This demonstrates clearly that while garbage is being collected, the script is paused.</span></p>
<p ><span></span></p>
<p ><span>Looking at the tick processor output from the Oz source code, the top function (updateSprites) was not optimized. In other words, the function in which the program spent the most time was also unoptimized. This strongly indicates that suspect #3 is the culprit. The source for updateSprites contained loops that looked like these:</span></p>
<pre class="prettyprint">
function updateSprites(dt) {
    for (var sprite in sprites) {
        sprite.position.x += 0.5 * dt;
        // 20 more lines of arithmetic computation.
    }
}
</pre>
<p ><span>Knowing V8 as well as they do, they immediately recognized that the for-i-in loop construct is sometimes not optimized by V8. In other words, if a function contains a for-i-in loop construct, it may not be optimized. This is a special case today, and will likely change in the future, that is, V8 may one day optimize this loop construct. Since we aren&rsquo;t V8 detectives and don&rsquo;t know V8 like the back of our hands, how can we determine why updateSprites was not optimized?</span></p>
<h3 id="toc-experiment-2" ><span>Experiment #2</span></h3>
<p ><span></span></p>
<p ><span>Running Chrome with this flag:
<pre class="prettyprint">
--js-flags="--trace-deopt --trace-opt-verbose"
</pre>
displays a verbose log of optimization and deoptimization data. Searching through the data for updateSprites we find:</span></p>
<p ><span></span></p>
<p ><span>[disabled optimization for updateSprites, reason: ForInStatement is not fast case]</span></p>
<p ><span></span></p>
<p ><span>Just as the detectives hypothesized, the for-i-in loop construct was the reason.</span></p>
<h2 id="toc-cased-closed">Case Closed</h2>
<p ><span></span></p>
<p ><span>After discovering the reason updateSprites was not optimized, the fix was simple, simply move the computation into its own function, that is:</span></p>
<pre class="prettyprint">
function updateSprite(sprite, dt) {
    sprite.position.x += 0.5 * dt;
    // 20 more lines of arithmetic computation.
}

function updateSprites(dt) {
    for (var sprite in sprites) {
        updateSprite(sprite, dt);
    }
}
</pre>
<p ><span>updateSprite will be optimized, resulting in far fewer HeapNumber objects, resulting in less frequent GC pauses. It should be easy for you to confirm this by performing the same experiments with new code. &nbsp;The careful reader will notice that double numbers are still being stored as properties. If profiling indicates it is worth it, changing </span><span >position</span><span>&nbsp;to be an array of doubles or a typed data array would further reduce the number of objects being created.</span></p>
<h2 id="toc-epilogue" >Epilogue</h2>
<p ><span></span></p>
<p ><span>The Oz developers didn&rsquo;t stop there. </span><span>Armed with the tools and techniques shared with them by the V8 detectives, they were able to find a few other functions that were stuck in deoptimization hell and factored the computation code into leaf functions which were optimized, resulting in even better performance.</span></p>
<p ><span></span></p>
<p ><span>Get out there and start solving some performance crimes!</span></p>

{% endblock %}
