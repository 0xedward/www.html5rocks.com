{% extends "tutorial.html" %}

{% block headtitle %}非同期JavaScriptプログラミング - HTML5アプリケーションの為の$.Deferredのパワー{% endblock %}
{% block pagetitle %}非同期JavaScriptプログラミング - HTML5アプリケーションの為の$.Deferredのパワー{% endblock %}
{% block pagebreadcrumb %}非同期JavaScriptプログラミング - HTML5アプリケーションの為の$.Deferredのパワー{% endblock %}
{% block date %}2012 年 8 月 24 日{% endblock %}

{% block browsersupport %}
<span class="browser opera supported"><span class="browser_name">Opera</span><span class="support">サポート済み</span></span>
<span class="browser ie supported"><span class="browser_name">Internet Explorer</span><span class="support">サポート済み</span></span>
<span class="browser safari supported"><span class="browser_name">Safari</span><span class="support">サポート済み</span></span>
<span class="browser ff supported"><span class="browser_name">Firefox</span><span class="support">サポート済み</span></span>
<span class="browser chrome supported"><span class="browser_name">Chrome</span><span class="support">サポート済み</span></span>
{% endblock %}

{% block content %}

<!--<h1>Asynchronous JavaScript Programming. The Power Of $.Deferred for HTML5 Application</h1>-->

<section>

  <p>
    スムーズで、レスポンシブなHTML5アプリケーションを構築する際に一番大事な側面の1つとして、全ての異なったアプリケーションのパーツ、例えばデータの取得・加工・アニメーション・UI要素などの間を同期させるという事があります。
  </p>

  <p>
    デスクトップやネイティブ環境との主な違いとして、ブラウザはスレッディングモデルにはアクセスできず、全てのUI(例えばDOM)に対してはシングルスレッドでしかアクセスが許されていない点があります。これは全てのアプリケーションロジックが常に同じスレッドに対してしか、アクセスや変更が出来ないという事を意味しています。このため、全てのアプリケーションは小さな単位で効率的に、またブラウザが提供する非同期な処理を最大限に使うように動作している事が大切になります。
  </p>

</section>

<section>
  <h2 id="toc-browserasync">ブラウザの非同期API</h2>

  <p>
    幸いにもブラウザは一般的に使用されるXHR(XMLHttpRequestか'AJAX')API、そしてIndexedDB、SQLite、HTML5ウェブワーカーや、わずかに知られる例としてはHTML5ジオロケーションAPIなどのようないくつかの非同期APIを備えています。transitionEndイベントのようなCSS3アニメーションなどのDOMに関連したいくつかのアクションも非同期にされています。
  </p>

  <p>
    ブラウザがアプリケーションロジックに提供する非同期プログラミングにはイベントまたはコールバックという手段があります。イベントベースの非同期APIでは、開発者は与えられたオブジェクト(例えばHTMLエレメントもしくは他のDOMオブジェクト)に対してイベントハンドラを登録して、適切な時にメインスレッドのイベントを発火させます。
  </p>

  <p>例として、イベントベースの非同期APIであるXHR APIを使用したコードはこのような感じになります：</p>

<pre class="prettyprint collapsible lang-js">
// /data以下のリソースをGETで取得する為にXHRオブジェクトを作成します
var xhr = new XMLHttpRequest();
xhr.open("GET","data",true);

// イベントハンドラを登録します
xhr.addEventListener('load',function(){
  if(xhr.status === 200){
      alert("We got data: " + xhr.response);
  }
},false) 

// 動作させます
xhr.send();
</pre>

  <p>
    CSS3のtransitionEndイベントを使ったイベントベースの非同期APIの他の例です。
  </p>
<pre class="prettyprint lang-js">
// idが'flyingCar'のHTMLエレメントを取得する
var flyingCarElem = document.getElementById("flyingCar");

// イベントハンドラの登録
// ('transitionEnd' for FireFox, 'webkitTransitionEnd' for webkit) 
flyingCarElem.addEventListener("transitionEnd",function(){
  // transitionが完了したら呼ばれます
  alert("The car arrived");
});

// アニメーションの発火のためCSS3のクラスを付けます
// 注意: いくつかのブラウザはあるtransitionをGPUに譲ってしまいます。
//       しかし、開発者はこの事を気にしてはいけないし、するべきでもありません。
flyingCarElemen.classList.add('makeItFly') 
</pre>

  <p>
    SQLiteやHTML5ジオロケーションのような他のブラウザAPIはコールバックベースになります。これは開発者が引数として関数を渡す事により、問題を解決する実装の基本とするという意味です。
  </p>

  <p>
    例えば、HTML5ジオロケーションではこのようなコードになります。
  </p>

<pre class="prettyprint lang-js">
// 完了した際に呼び出すコールバック関数を渡す
navigator.geolocation.getCurrentPosition(function(position){  
            alert('Lat: ' + position.coords.latitude + ' ' +  
                  'Lon: ' + position.coords.longitude);  
});  
</pre>

  <p>
    この場合、メソッドを呼び出し、要求の解決の為コールバックとして関数を渡すだけです。ブラウザはこれを同期・非同期に関わらず単一の機能として実装し、開発者には実装の詳細に関わらず、単一のAPIとして提供できるわけです。
  </p>
</section>

<section>
  <h2 id="toc-async-application">非同期化しやすいアプリケーションを作る</h2>
  <p>
    良く設計されたアプリケーションは、ブラウザの組み込みの非同期API以上に、低レベルAPIにおける非同期のやり方を公開すべきです。
    I/OのソートやCPUに負荷がかかる処理をする場合は特にそうです。例えば、APIがデータを取得する際は非同期であるべきですし、
    この例のようにはすべきではありません。:
  </p>

<pre class="prettyprint lang-js">
// 間違い: この処理はデータの取得時にUIをフリーズさせてしまいます。
var data = getData();
alert("We got data: " + data);
</pre>

  <p>
    このAPIの設計では<b>getData()</b>をデータを取得するまでUIをフリーズさせてしまうブロッキング状態にしてしまいます。
    もしデータがJavaScriptのコンテキストの中でローカルなものであればそれ程の問題にはなりませんが、もしデータの取得に
    ネットワークやローカルのSQLiteやインデックスストアでの操作が必要ならば、UIにとても大きなインパクトを与えかねません。
  </p>

  <p>
    正しい設計としては、積極的に時間がかかる可能性のある全てのアプリケーションAPIを非同期にする事ですが、
    最初から同期的に書かれているアプリケーションのコードを非同期にするのは大変な作業になります。
  </p>

  <p>
    例として単純化されたgetData() APIはこのようになるでしょう。:
  </p>

<pre class="prettyprint lang-js">
getData(function(data){
   alert("We got data: " + data);
});
</pre>

  <p>
    このアプローチで良い事は、アプリケーションUIのコードを最初から非同期中心のコードにできる事と、基本APIを非同期が必要かどうかを後から決める事ができる点です。
  </p>

  <p>
    注意点として、全てのアプリケーションAPIを非同期にする必要もすべきでも無いという事です。重要なルールはどのようなタイプのI/O、または重たい処理(15ms以上のどのような処理でも)でもそうですが、最初の実行が同期的だったとしても、初めから非同期処理として公開されるべきという点です。
  </p>

</section>

<section>
  <h2 id="toc-handling-failures">Handling Failures</h2>
  
  <p>
    One catch of asynchronous programing is that the traditional try/catch way to handle
    failures does not really work anymore, as errors usually happen in another thread.
    Consequently, the callee needs to have a structured way to notify the caller when
    something goes wrong during the processing.     
  </p>
  
  <p>
    In an event-based asynchronous API this is often accomplished by the application code
    querying the event or object when receiving the event. For callback based
    asynchronous APIs, the best practice is to have a second argument that takes a
    function that would be called in case of a failure with the appropriate error
    information as argument.     
  </p>
  
  <p>Our getData call would look like this:</p>

<pre class="prettyprint lang-js">
// getData(successFunc,failFunc);  
getData(function(data){
  alert("We got data: " + data);
}, function(ex){
  alert("oops, some problem occured: " + ex);
});
</pre>

</section>

<section>
  <h2 id="toc-async-with-deferred">Putting it together with $.Deferred</h2>
  
  <p>
    One limitation of the above callback approach is that it can become really cumbersome
    to write even moderately advanced synchronization logic.     
  </p>

  <p>
    For example, if you need to wait for two asynchronous API to be done before doing a
    third one, code complexity can rise quickly.     
  </p>  
  
  <pre class="prettyprint lang-js">
// first do the get data.   
getData(function(data){
  // then get the location
  getLocation(function(location){
    alert("we got data: " + data + " and location: " + location);
  },function(ex){
    alert("getLocation failed: "  + ex);
  });
},function(ex){
  alert("getData failed: " + ex);
});
</pre>
  
  <p>
    Things can even get more complex when the application needs to make the same call
    from multiple parts of the application, as every call will have to perform these multi
    step calls, or the application will have to implement its own caching mechanism.     
  </p>
  
  <p>
    Luckily, there is a relatively old pattern, called Promises (kind of similar to
    <a href="http://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/Future.html">Future</a> in Java) and a robust and modern implementation 
    in jQuery core called <a href="http://api.jquery.com/category/deferred-object/">$.Deferred</a> that provides a simple and powerful solution to asynchronous programing.    
  </p>  
  
  <p>
    To make it simple, the Promises pattern defines that the asynchronous API returns a
    Promise object which is kind of a “Promise that the result will be resolved with the
    corresponding data.” To get the resolution, the caller gets the Promise object and
    calls a <em>done(successFunc(data))</em> which will tell the Promise object to call this
    <em>successFunc</em> when the “data” is resolved.     
  </p>
  
  <p>
    So, the getData call example above becomes like this:     
  </p>
  
<pre class="prettyprint lang-js">
// get the promise object for this API  
var dataPromise = getData();

// register a function to get called when the data is resolved
dataPromise.done(function(data){
  alert("We got data: " + data);
});

// register the failure function
dataPromise.fail(function(ex){
  alert("oops, some problem occured: " + ex);
});

// Note: we can have as many dataPromise.done(...) as we want. 
dataPromise.done(function(data){
  alert("We asked it twice, we get it twice: " + data);
});
</pre>  

  <p>
    Here, we get the <em>dataPromise</em> object first and then call the <em>.done</em> method to register
    a function we want to get called back when the data gets resolved. We can also call
    the <em>.fail</em> method to handle the eventual failure.  Note that we can have as many <em>.done</em>
    or <em>.fail</em> calls as we need since the underlying Promise implementation (jQuery code) will 
    handle the registration and callbacks.      
  </p>
  
  <p>
    With this pattern, it is relatively easy to implement more advanced synchronization
    code, and jQuery already provides the most common one such a <a href="http://api.jquery.com/jQuery.when/">$.when</a>.     
  </p>
  
  <p>
    For example, the nested <em>getData</em>/<em>getLocation</em> callback above would become something like:
  </p>
  
<pre class="prettyprint lang-js">
// assuming both getData and getLocation return their respective Promise
var combinedPromise = $.when(getData(), getLocation())

// function will be called when both getData and getLocation resolve
combinePromise.done(function(data,location){
  alert("We got data: " + dataResult + " and location: " + location);
});  
</pre>

  <p>
    And the beauty of it all is that jQuery.Deferred makes it very easy for developers to
    implement the asynchronous function. For example, the getData could look something like this: 
  </p>
  
<pre class="prettyprint lang-js">
function getData(){
  // 1) create the jQuery Deferred object that will be used
  var deferred = $.Deferred();
  
  // ---- AJAX Call ---- //
  XMLHttpRequest xhr = new XMLHttpRequest();
  xhr.open("GET","data",true);
  
  // register the event handler
  xhr.addEventListener('load',function(){
    if(xhr.status === 200){
      // 3.1) RESOLVE the DEFERRED (this will trigger all the done()...)
      deferred.resolve(xhr.response);
    }else{
      // 3.2) REJECT the DEFERRED (this will trigger all the fail()...)
      deferred.reject("HTTP error: " + xhr.status);
    }
  },false) 
  
  // perform the work
  xhr.send();
  // Note: could and should have used jQuery.ajax. 
  // Note: jQuery.ajax return Promise, but it is always a good idea to wrap it
  //       with application semantic in another Deferred/Promise  
  // ---- /AJAX Call ---- //
  
  // 2) return the promise of this deferred
  return deferred.promise();
}
  
</pre>

  <p>
    So, when the getData() is called, it first creates a new jQuery.Deferred object (1) 
    and then returns its Promise (2) so that the caller can register its done and fail 
    functions. Then, when the XHR call returns, it either resolves the deferred (3.1) or 
    reject it (3.2). Doing the deferred.resolve will trigger all the done(...) functions 
    and other promise functions (e.g., then and pipe) and calling deferred.reject will 
    call all the fail() functions. 
  </p>  
</section>
<section>
  <h2 id="toc-use-cases">Use Cases</h2>

  <p>
    Here are some good use cases where Deferred can be very useful:
  </p>

  <p>
    <b>Data Access:</b> Exposing data access APIs as $.Deferred is often the right design. 
    This is obvious for remote data, as synchronous remote calls would completely ruin the 
    user experience, but is also true for local data as often the lower level APIs (e.g., 
    SQLite and IndexedDB) are asynchronous themselves. The Deferred API''s $.when and .pipe 
    are extremely powerful to synchronize and chain asynchronous sub-queries.
  </p>
  <p>
    <b>UI Animations:</b> Orchestrating one or more animations with transitionEnd events 
    can be quite tedious, especially when the animations are a mixed of CSS3 animation 
    and JavaScript (as it is often the case). Wrapping the animation functions as Deferred 
    can significantly reduce the code complexity and improve flexibility. Even a simple 
    generic wrapper function like cssAnimation(className) that will return the Promise 
    object that gets resolved on transitionEnd could be of a great help.
  </p>

  <p>
    <b>UI Component Display:</b> This is a little bit more advanced, but advanced HTML 
    Component frameworks should use the Deferred as well. Without going too much into 
    the details (this will be the subject of another post), when an application needs to 
    display different parts of the user interface, having the lifecycle of those 
    components encapsulated in Deferred allows greater control of the timing. 
  </p>

  <p>
    <b>Any browser asynchronous API:</b> For normalization purpose, it is often a good 
    idea to wrap the browser API calls as Deferred. This takes literally 4 to 5 lines 
    of code each, but will greatly simplify any application code. As show in the above 
    getData/getLocation pseudo code, this allows the applications code to have one 
    asynchronous model across all types of API (browsers, application specifics, and 
    compound).
  </p>

  <p>
    <b>Caching:</b> This is kind of a side benefit, but can be very useful in some 
    occasion. Because the Promise APIs (e.g., .done(..) and .fail(..)) can be called 
    before or after the asynchronous call is performed, the Deferred object can be 
    used as a caching handle for an asynchronous call. For example, a CacheManager 
    could just keep track of Deferred for given requests, and return the Promise of 
    the matching Deferred if it has not be invalidated. The beauty is that the caller 
    does not have to know if the call has already been resolved or is in the process 
    of being resolved, its callback function will get called exactly the same way. 
  </p>
</section>

<section>
  <h2 id="toc-conclusion">Conclusion</h2>
  
  <p>
    While the $.Deferred concept is simple, it can take time to get a good handle on it.
    However, given the nature of the browser environment, mastering asynchronous
    programing in JavaScript is a must for any serious HTML5 application developer and
    the Promise pattern (and the jQuery implementation) are tremendous tools 
    to make asynchronous programming reliable and powerful.    
  </p>  
</section>

{% endblock %}

