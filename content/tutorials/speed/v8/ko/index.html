{% extends "tutorial.html" %}

{% block pagebreadcrumb %}Performance Tips for Javascript in V8{% endblock %}

{% block head %}
{% endblock %}

{% block iscompatible %}

{% endblock %}

{% block html5badge %}
{% endblock %}


{% block content %}

<h2 id="toc-introduction">소개</h2>

<p>Daniel Clifford는 V8의 JavaScript 처리 성능을 향상시키기 위한 팁과 트릭에 대하여 <a href="http://www.youtube.com/watch?v=UJPdhx5zTaw">Google I/O에서 훌륭한 발표</a>를 했습니다. Daniel은 C++과 JavaScript 간의 성능 차이를 주의 깊게 분석하고 JavaScript의 동작 방식을 유념하여 코드를 작성하면 더 빠른 속도를 낼 수 있다고 말합니다. Daniel의 이야기 중에서 가장 중요한 포인트를 요약해서 이 글에 담았는데요, 성능에 대한 지침이 바뀌면 이 글의 내용 역시 업데이트하겠습니다.</p>

<h2 id="toc-mostimportant">가장 중요하게 생각해야 할 것</h2>

<p>성능 향상에 대한 모든 것을 담는 다는 것은 중요한 일입니다. 그러나 성능을 진단하는 일은 중독성이 있어서, 때로는 너무 깊은 부분에 초점을 맞추려다가 실질적인 문제를 놓치기도 합니다. 전체적인 관점에서 웹 애플리케이션의 성능을 바라볼 필요가 있습니다. 이러한 성능 팁에 초점을 맞추기 전에 <a href="https://developers.google.com/speed/pagespeed/">PageSpeed<</a> 같은 도구로 코드를 분석해서 점수를 높히는 게 좋습니다. 이렇게하면 성급한 최적화를 피할 수 있습니다.</p>

<p>좋은 성능을 얻기 위한 가장 기본적으로 생각해야 할 세가지입니다.</p>
<ul>
	<li>문제가 발생하기 전에 준비합니다.</li>
	<li>그 다음에, 문제의 핵심을 파악하고 이해합니다.</li>
	<li>마지막으로 문제가 되는 것을 수정합니다.</li>
</ul>

<p>이러한 단계를 수행하기 위해서, V8이 어떻게 JS 코드를 최적화하는지 이해하는 것은 중요한 일이라고 할 수 있습니다. JS 런타임 디자인을 염두에 두고 코드를 작성할 수 있기 때문이죠. 이용 가능한 도구가 무엇이 있는지, 그리고 어떤 도움을 줄 수 있는지에 대해서 알아두는 것 또한 중요한 일입니다. Daniel은 개발자 도구 사용법에 대해서 몇 가지를 더 설명하고 있습니다만, 이 글에서는 V8 엔진 설계의 중요한 부분 몇 개만 다룹니다.</p>

<p>자, 그럼 V8 사용 팁 속으로 들어가보시죠!</p>

<h2 id="toc-topic-hiddenclasses">Hidden Classes</h3>

<p>JavaScript는 컴파일을 할 때 이용할 type 정보가 제한적입니다. JavaScript는 런타임에 type을 변경할 수 있기 때문에 컴파일 시에 JS 코드의 type을 추론하는 비용이 비쌀 것이라고 예측할 수 있습니다. 아마 JavaScript 성능을 어떻게 C++의 성능에 근접한 수준으로 끌어올릴 수 있을지에 대한 의문이 생길 것입니다. 그러나, V8은 런타임 시에 객체에 사용할 내부적으로 만든 hidden type을 가지고 있습니다. 같은 hidden class를 가지고 있는 객체는 다음에 같은 최적화된 생성 코드를 사용할 수 있습니다.</p>

<p>예제:</p>
<pre class="prettyprint">function Point(x, y) {
  this.x = x;
  this.y = y;
}

var p1 = new Point(11, 22);
var p2 = new Point(33, 44);
// At this point, p1 and p2 have a shared hidden class
p2.z = 55;
// warning! p1 and p2 now have different hidden classes!</pre>

<p>객체 인스턴스 p2에 멤버 ".z"를 추가하기 전까지, p1과 p2는 내부적으로 같은 hidden class를 갖습니다. 이로써 V8은 p1이나 p2를 다루는 JavaScript 코드에 대한 단일 버전의 최적화된 어셈블리어를 만들 수 있습니다. 같은 JavaSript 코드의 hidden class가 달라지는 원인을 찾아서 막을 수 있다면, 더 나은 성능을 얻을 수 있는 것이죠.</p>

<h3>따라서:</h3>
<ul>
	<li>모든 객체 멤버를 생성자 함수 안에서 초기화하세요(그래야 나중에 인스턴스가 멤버의 type을 변경하지 않습니다).</li>
	<li>항상 같은 순서로 객체 멤버를 초기화합니다.</li>
</ul>

<h2 id="toc-topic-numbers">Numbers</h3>

<p>V8은 type이 변할 때 효율적으로 값을 나타내는 태그를 사용합니다. 사용자가 사용하고 있는 값을 통해서 어떤 number type을 다루고 있는지 추론합니다. 이러한 type은 동적으로 변할 수 있기 때문에, 일단 V8이 추론을 해서 type을 결정하면, 효율적으로 값을 나타낼 수 있는 태그를 사용합니다. 그러나, 이러한 type을 나타내는 태그를 변경하는 데에 가끔 비용이 들기 때문에, number type을 지속적으로 사용하는 것이 가장 좋습니다. 일반적으로 적합하다면, 31비트 부호있는 정수를 사용하는 것이 최적입니다.</p>

<p>예제:</p>
<pre class="prettyprint">var i = 42;  // this is a 31-bit signed integer
var j = 4.2;  // this is a double-precision floating point number</pre>



<h3>결과:</h3>
<ul>
	<li>31비트 부호있는 정수로 나타낼 수 있는 숫자 값 사용을 우선적으로 검토하세요.</li>
</ul>

<h2 id="toc-topic-numbers">Arrays</h3>

<p>In order to handle large and sparse arrays, there are two types of array storage internally:
<ul>
	<li>Fast Elements: linear storage for compact key sets
	<li>Dictionary Elements: hash table storage otherwise
</ul>
<p>It's best not to cause the array storage to flip from one type to another.
<h3>Therefore:</h3>
<ul>
	<li>Use contiguous keys starting at 0 for Arrays
	<li>Don't pre-allocate large Arrays (e.g. > 64K elements) to their maximum size, instead grow as you go
	<li>Don't delete elements in arrays, especially numeric arrays
	<li>Don't load uninitialized or deleted elements:
</ul>
<pre class="prettyprint">a = new Array();
for (var b = 0; b &lt; 10; b++) {
  a[0] |= b;  // Oh no!
}
//vs.
a = new Array();
a[0] = 0;
for (var b = 0; b &lt; 10; b++) {
  a[0] |= b;  // Much better! 2x faster.
}</pre>

<p>Also, Arrays of doubles are faster - the array's hidden class tracks element types, and arrays containing only doubles are unboxed (which causes a hidden class change).However, careless manipulation of Arrays can cause extra work due to boxing and unboxing - e.g.
<pre class="prettyprint">var a = new Array();
a[0] = 77;   // Allocates
a[1] = 88;
a[2] = 0.5;   // Allocates, converts
a[3] = true; // Allocates, converts</pre>

is less efficient than:

<pre class="prettyprint">var a = [77, 88, 0.5, true];</pre>

because in the first example the individual assignments are performed one after another, and the assignment of a[2] causes the Array to be converted to an Array of unboxed doubles, but then the assignment of a[3] causes it to be re-converted back to an Array that can contain any values (Numbers or objects).  In the second case, the compiler knows the types of all of the elements in the literal, and the hidden class can be determined up front.

<h3>Therefore:</h3>
<ul>
	<li>Initialize using array literals for small fixed-sized arrays
	<li>Preallocate small arrays (&lt;64k) to correct size before using them
	<li>Don't store non-numeric values (objects) in numeric arrays
	<li>Be careful not to cause re-conversion of small arrays if you do initialize without literals.
</ul>

<h2 id="toc-topic-compilation">JavaScript Compilation</h3>

<p>Although JavaScript is a very dynamic language, and original implementations of it were interpreters, modern JavaScript runtime engines use compilation.  V8 (Chrome's JavaScript) has two different Just-In-Time (JIT) compilers, in fact:
	<ul>
		<li>The "Full" compiler, which can generate good code for any JavaScript
		<li>The Optimizing compiler, which produces great code for most JavaScript, but takes longer to compile.
	</ul>

<h2>The Full Compiler</h2>
<p>In V8, the Full compiler runs on all code, and starts executing code as soon as possible, quickly generating good but not great code.  This compiler assumes almost nothing about types at compilation time - it expects that types of variables can and will change at runtime.  The code generated by the Full compiler uses Inline Caches (ICs) to refine knowledge about types while program runs, improving efficiency on the fly.</p>

<p>The goal of Inline Caches is to handle types efficiently, by caching type-dependent code for operations; when the code runs, it will validate type assumptions first, then use the inline cache to shortcut the operation.  However, this means that operations that accept multiple types will be less performant.

<h3>Therefore:</h3>
<ul>
	<li>Monomorphic use of operations is preferred over polymorphic operations</li>
</ul>
<p>Operations are monomorphic if the hidden classes of inputs are always the same - otherwise they are polymorphic, meaning some of the arguments can change type across different calls to the operation.  For example, the second add() call in this example causes polymorphism:

<pre class="prettyprint">function add(x, y) {
  return x + y;
}

add(1, 2);      // + in add is monomorphic
add("a", "b");  // + in add becomes polymorphic</pre>

<h2>The Optimizing Compiler</h2>
<p>In parallel with the full compiler, V8 re-compiles "hot" functions (that is, functions that are run many times) with an optimizing compiler.  This compiler uses type feedback to make the compiled code faster - in fact, it uses the types taken from ICs we just talked about!</p>

<p>In the optimizing compiler, operations get speculatively inlined (directly placed where they are called).  This speeds execution (at the cost of memory footprint), but also enables other optimizations.  Monomorphic functions and constructors can be inlined entirely (that's another reason why monomorphism is a good idea in V8).</p>

<p>You can log what gets optimized using the standalone "d8" version of the V8 engine:
<pre class="prettyprint">d8 --trace-opt primes.js</pre>
(this logs names of optimized functions to stdout.)</p>

<p>Not all functions can be optimized, however - some features prevent the optimizing compiler from running on a given function (a "bail-out").  In particular, the optimizing compiler currently bails out on functions with try {} catch {} blocks!

<h3>Therefore:</h3>
<ul>
	<li>Put perf-sensitive code into a nested function if you have try {} catch {} blocks:
<pre class="prettyprint">function perf_sensitive() {
  // Do performance-sensitive work here
}

try {
  perf_sensitive()
} catch (e) {
  // Handle exceptions here
}</pre>
</li>
</ul>

<p>This guidance will probably change in the future, as we enable try/catch blocks in the optimizing compiler. You can examine how the optimizing compiler is bailing out on functions by using the "--trace-opt" option with d8 as above, which gives you more information on which functions were bailed out:
<pre class="prettyprint">d8 --trace-opt primes.js</pre>

<h2>De-optimization</h2>
<p>Finally, the optimization performed by this compiler is speculative - sometimes it doesn't work out, and we back off.  The process of "deoptimization" throws away optimized code, and resumes execution at the right place in "full" compiler code.  Reoptimization might be triggered again later, but for the short term, execution slows down.  In particular, causing changes in the hidden classes of variables after the functions have been optimized will cause this deoptimization to occur.</p>

<h3>Therefore:</h3>
<ul>
	<li>Avoid hidden class changes in functions after they are optimized</li>
</ul>

<p>You can, as with other optimizations, get a log of functions that V8 had to deoptimize with a logging flag:
<pre class="prettyprint">d8 --trace-deopt primes.js</pre>

<h2>Other V8 Tools</h2>
<p>By the way, you can also pass V8 tracing options to Chrome on startup:
<pre class="prettyprint">"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --js-flags="--trace-opt --trace-deopt"</pre>

<p>In addition to using the developer tools profiling, you can also use d8 to do profiling:
<pre class="prettyprint">% out/ia32.release/d8 primes.js --prof</pre>
<p>This uses the built-in sampling profiler, which takes a sample every millisecond and writes v8.log.</p>

<h2>In Summary...</h2>
It's important to indentify and understand how the V8 engine works with your code to prepare to build performant JavaScript.  Once more, the basic advice is:
<ul>
	<li>Be prepared before you have (or notice) a problem</li>
	<li>Then, identify and understand the crux of your problem</li>
	<li>Finally, fix what matters</li>
</ul>
<p>This means you should ensure the problem is in your JavaScript, by using other tools like PageSpeed first; possibly reducing to to pure JavaScript (no DOM) before collecting metrics, and then use those metrics to locate bottlenecks and eliminate the important ones.  Hopefully Daniel's talk (and this article) will help you understand better how V8 runs JavaScript - but be sure to focus on optimizing your own algorithms, too!</p>

<h2 id="toc-references">References</h2>
<ul>
  <li><a href="http://www.youtube.com/watch?v=UJPdhx5zTaw">Daniel's talk on YouTube</a></li>
  <li><a href="http://v8-io12.appspot.com/">Daniel's slide deck</a></li>
  <li><a href="http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html">I-want-to-optimize-my-JS-application-on-V8 checklist by Vyacheslav Egorov, V8 Engineer</a></li>
</ul>

{% endblock %}
