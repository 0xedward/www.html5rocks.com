{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.talkinghead:before {
  background-image: url(/static/images/profiles/75/paullewis.75.png);
}
</style>
{% endblock %}

{% block iscompatible %}
{% block translator %}
<div class="translator">
  <strong>翻訳:</strong> <a href="https://github.com/kyo-ago">kyo_ago</a>, <a href="https://github.com/negibouze">Yoshiaki Itakura</a>, <a href="https://github.com/kaseijin">kaseijin</a>, <a href="https://github.com/sgrcb">Kayo Sato</a>, <a href="https://github.com/mtsmfm">Fumiaki MATSUSHIMA</a>, <a href="https://github.com/takyana">Tak Yanagida</a>
</div>
{% endblock %}

{% block content %}

<p>Avoiding paints is critical to achieving a silky smooth frame rate, especially on mobile. Sometimes, however, paints crop up in the most unusual of places. This article looks at why animated GIFs can cause unnecessary paints to occur, and the remarkably simple fix you can apply.</p>
<p>描画を避けることは、特にモバイル端末上で、絹のように滑らかなフレームレートを達成するために重要です。しかし時には、描画はひどく変わった場所で発生します。この記事では、アニメーションGIFが不要な描画を発生させうる理由と、非常に簡単な修正方法を見ていきます。</p>

<blockquote class="commentary talkinghead" id="unnecessary-paints">Last time we looked at ways to <a href="http://www.html5rocks.com/en/tutorials/speed/unnecessary-paints/">avoid hover effects during scrolls</a>. If you've not seen that, check it out now!</blockquote>
<blockquote class="commentary talkinghead" id="unnecessary-paints">前回は、<a href="http://www.html5rocks.com/en/tutorials/speed/unnecessary-paints/">スクロール時にホバー効果を避ける</a>方法を見ました。まだ見ていない場合は、読んでみてください。</blockquote>

<h2 id="toc-layers">Layers of loveliness</h2>
<h2 id="toc-layers">素晴らしきレイヤー</h2>

<p>As you probably know, modern browsers may paint groups of DOM elements into separate "images", called layers. Sometimes there's one layer for the entire page, sometimes there are hundreds or &mdash; in rare cases &mdash; thousands!</p>
<p>最近のブラウザは広く知られているように、DOM要素のグループをレイヤーと呼ばれる別のイメージとして描画します。ページ全体で一つのレイヤーの場合もありますが、ときには何百、希なケースでは何千ものレイヤーがあります！</p>

<p>When DOM elements are grouped together into a layer and one of the elements changes visually, we end up having to paint not just the changed element, but <em>all the other elements in the layer that overlap the changed element as well</em>. Painting one thing on top of another results in the overwritten pixels being effectively "lost" forever; if you want the original pixels back you need to repaint them.</p>
<p>複数のDOM要素が一つのレイヤーへグループ化された状態で、その中の一つが視覚的に変化するとき、変更のあった要素だけでなく、変更のあった要素と重なるレイヤーに存在する全ての要素が描画されなければいけません。ある描画結果の上位レイヤーに何かを描画すると、上書きされたピクセルは永遠に失われます。元のピクセルを復元したい場合、それらを再描画する必要があります。</p>

<p>Sometimes, therefore, we want to isolate one element from the others so that when it gets painted we won't need to repaint the other elements that <em>haven't</em> changed. For example, when you combine a fixed page header with scrollable content, you have to repaint the header each time the content scrolls, as well as the newly visible content. By placing the header in a separate layer, the browser can optimize scrolling. When you scroll, the browser can move the layers around &mdash; probably with the help of the GPU &mdash; and avoid repainting either layer.</p>
<p>そこで、変更されていない他の要素を再描画する必要がないように、一つの要素を他の要素から分離したくなるときがあります。例えば、固定のページヘッダーとスクロール可能なコンテンツを組み合わせたとき、コンテンツがスクロールする度に新たに表示されるコンテンツだけでなく、ヘッダーを再描画する必要があります。別のレイヤーにヘッダを配置することで、ブラウザがスクロールを最適化できます。スクロールするとブラウザは、おそらくGPUの助けを借りてレイヤーを動かし回るか、レイヤーを再描画しないようにします。</p>

<p>Each additional layer increases memory consumption and adds performance overhead, so the goal is to group the page into as few layers as possible while maintaining good performance.</p>
<p>レイヤーの追加はメモリ消費の増加、パフォーマンスのオーバーヘッドを発生させるため、良好な性能を維持しつつ、できるだけ少ないレイヤーにグループ化することが目標です。</p>

<blockquote class="commentary talkinghead" id="layer-intro">If you want a more detailed breakdown of how layers are created and used definitely check out <a href="http://www.html5rocks.com/en/tutorials/speed/layers/">Tom Wiltzius's intro to the subject</a>.</blockquote>
<blockquote class="commentary talkinghead" id="layer-intro">もしレイヤーがどのように生成され明確に使用されるのか、より分類された詳細を知りたい場合は<a href="http://www.html5rocks.com/en/tutorials/speed/layers/">Tom Wiltziusのイントロダクション</a>を参照してください。</blockquote>

<h2 id="toc-animated-gifs">What does this all have to do with animated GIFs?</h2>
<h2 id="toc-animated-gifs">これとアニメーションGIFがどう関係するのでしょうか？</h2>

<p>Well let's have a look at this picture:</p>
<p>まずはこの図を見てください。</p>

<figure>
  <img src="layers.jpg" />
  <figcaption>Figure 1: A web app broken down into four layers.</figcaption>
  <figcaption>図1：4層に分けられたWebアプリ</figcaption>
</figure>

<p>This is a potential layer setup for a simple app. There are four layers here: three of them (layers 2 to 4) are interface elements; the back layer is a loader, which happens to be an animated GIF. In the normal flow you show the loader (layer 1) while your app loads, then as everything finishes you would show the other layers. But here's the key: <em>you need to hide the animated GIF.</em></p>
<p>これはシンプルなアプリケーションを階層化したものです。4層うちの3層（2層から4層）はインターフェイスの層です。背面レイヤー (1層) はアニメーションGIFのために発生するローダーです。通常のフローではアプリの読み込み中はローダー(1層)を表示し、すべてが終了すると他のレイヤーを表示します。ここでアニメーションGIFを(他のレイヤーで覆い隠すのではなく)非表示にすることが重要なのです。</p>

<h2 id="toc-but-why">But why do I need to hide it?!</h2>
<h2 id="toc-but-why">なぜ非表示にする必要があるのですか？</h2>

<p>Good question. In a perfect world the browser would simply check the GIF’s visibility for you and avoid painting automatically. Unfortunately, checking whether the animated GIF is obscured or visible on the screen is typically <em>more</em> expensive than simply painting it, so it gets painted.</p>
<p>これは良い質問です。理想は、ブラウザーがGIFが表示されているかどうかをチェックし、自動的に描画されるのを避けることです。しかし、アニメーションGIFが隠されているか表示されているかをチェックすると、一般的にただ描画するよりも高負荷になるため、チェックせずに描画されます。</p>

<p>In the best case the GIF is in its own layer and the browser only has to paint and upload it to the GPU. But in the worst case all your elements might be grouped into a single layer and the browser has to repaint <em>every single element</em>. And, when it’s done, it still needs to upload everything to the GPU. All of this is work occurs for every GIF frame, despite the fact that the user can’t even see the GIF!</p>
<p>最も良いのは、GIFが独自のレイヤーにあり、ブラウザがそのレイヤーの描画とGPUへのアップロードを行うだけという場合です。最悪の場合、すべての要素が一つのレイヤーにグループ化され、そうなるとブラウザは<em>すべての要素を再描画</em>しなくてはなりません。再描画が終わってからも、GPUにすべてをアップロードする必要があります。これがGIFの毎フレームに起こるのです。それも、たとえユーザーがそのGIFを見られなくても起こってしまうんです！</p>

<p>On desktops you can probably get away with this kind of painting behavior because the CPUs and GPUs are more powerful, and there's plenty of bandwidth for transferring data between the two. On mobile, however, painting is extremely expensive so you must take great care.</p>
<p>デスクトップPCではCPUとGPUが高性能であり、データを転送するための十分な帯域幅がありますので、おそらくこれらの描画処理の振る舞いは気にしなくて良いでしょう。しかし、モバイル端末では描画処理はとても高負荷であるため、細心の注意を払う必要があります。</p>

<h2 id="toc-which-browsers">Which browsers does this affect?</h2>
<h2 id="toc-which-browsers">影響のあるブラウザは?</h2>

<p>As is often the way, behaviors differ between browsers. Today Chrome, Safari and Opera all repaint, even if the GIF is obscured. Firefox, on the other hand, figures out that the GIF is obscured and doesn’t need to be repainted. Internet Explorer remains something of a black box, and even in IE11 &mdash; since the F12 tools are still being developed &mdash; there is no indication as to whether or not any repainting is taking place.</p>
<p>よくあることですが、ブラウザ毎に挙動は異なります。今現在の Chrome や Safari 、Opera は GIF が隠されている場合にも再描画します。一方、FirefoxはGIFが隠されている場合は再描画の必要がないと判断してくれます。Internet Explorer は、 IE 11 ですらどうなっているか未知数です - F12 開発者ツールはまだ開発中なので - 再描画がされているかどうかを知る方法がありません。</p>

<h2 id="toc-devtools">How can I tell if I have this problem?</h2>
<h2 id="toc-devtools">問題があるかどうかを確認するには？</h2>

<p>The easiest way is to use "Show paint rectangles" in Chrome DevTools. Load DevTools and press the cog in the lower right corner (<img src="cog.png" />) and choose <strong>Show paint rectangles</strong> under the <strong>Rendering</strong> section.</p>
<p>Chrome 開発ツールの「Show paint rectangles」を使うのが最も簡単です。開発ツールを起動し、右下の歯車マークを押して「Rendering」内の「Show paint rectangles」を選択します。</p>

<figure>
  <img src="showpaintrects.png" class="bordered" />
  <figcaption>Figure 2: Enabling Show paint rectangles inside Chrome DevTools.</figcaption>
  <figcaption>図2：Chrome開発者ツールで、Show paint rectanglesを有効にする</figcaption>
</figure>

<p>Now all you need to do is look for a red rectangle like this:</p>
<p>表示されたら、このような赤い矩形部分を確認してください。</p>

<figure>
  <img src="paintedgif.png" />
  <figcaption>Figure 3: DevTools’ Show Paint Rectangles hints at animated GIF problems with a red rectangle.</figcaption>
  <figcaption>図3：アニメーションGIFの問題を赤い矩形で表示する開発ツールの矩形描画表示</figcaption>
</figure>

<p>The little red box on the screen shows that Chrome is repainting something. You know that there’s a loader GIF hidden behind the other elements, so when you see a red box like this you need to hide the visible elements and check if you have left the animated GIF spinning away. If you have then you need to pop some CSS or JavaScript in place to apply <code>display: none</code> or <code>visibility: hidden</code> to it or its parent element. Of course if it's just a background image then you should make sure to remove it.</p>
<p>この小さな赤いボックスは、Chromeブラウザがスクリーン上で何かを再描画していることを示しています。ローディングのアニメーションGIFが他の要素の下に隠れているのは分かっているので、このような赤いボックスが見えたら、表示されている要素を非表示にして、アニメーションGIFが動いているか確認してください。もし動いていたら、アニメーションGIFかその要素にCSSかJavaScriptでdisplay: none 、またはvisibility: hiddenを適用します。もちろん、これが単なる背景画像だった場合は、必ず削除すべきです。</p>

<p>If you want to see an example of this behavior in a live site, check out <a href="http://allegro.pl/listing/listing.php?string=phone">Allegro</a>, where each product’s image has a loader GIF that is obscured rather than explicitly hidden.</p>
<p>実際のサイトでこの挙動を確認したい場合は、<a href="http://allegro.pl/listing/listing.php?string=phone">アレグロ</a>というサイトで、各商品画像のローディングのアニメーションGIFが、明示的にhiddenになっているのではなく、隠されていることを見ることができます。</p>

<h2 id="toc-conclusion">Conclusion</h2>
<h2 id="toc-conclusion">結論</h2>

<p>Achieving 60fps means doing <em>only</em> what's needed to render the page and no more. Removing excess paints is a critical step in achieving this goal. Animated GIFs that are left running can trigger unnecessary paints, something which you can find and debug easily with DevTools' Show paint rectangles tool.</p>
<p>秒間60フレームを達成するということは、そのページをレンダリングするのに必要なことだけをやって、それ以外はやらないことを意味します。余分な描画を排除することは、この目標を達成する上で重要なステップです。実行したままになっているアニメーションGIFは不要な描画を引き起こすことがありますが、これは、DevToolsの「Show paint rectangleツール」で容易に見つけてデバッグできます。</p>

<p>Now, you didn't leave that animated kitten loader GIF running forever, did you?</p>
<p>あなたはもう、可愛らしいローディングのアニメーションGIFが実行しっぱなしにすることはないですよね。</p>

{% endblock %}
