
{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.talkinghead-cm:before {
  background-image: url(/static/images/profiles/75/coltmcanlis.75.png);
  background-position: 0px 0px !important;
}
.talkinghead-ja:before {
  background-image: url(/static/images/profiles/75/jakearchibald.75.png);
  background-position: 0px 0px !important;
}
.talkinghead-ao:before {
  background-image: url(/static/images/profiles/75/addyosmani.75.png);
  background-position: 0px 0px !important;
}
article.tutorial .notice.fact {
  position: relative;
  padding-left: 25px;
}
article.tutorial .notice.fact:before {
  position: absolute;
  top: -5px;
  left: -10px;
  text-transform: uppercase;
  -webkit-transform: rotateZ(-30deg);
  -moz-transform: rotateZ(-30deg);
  -o-transform: rotateZ(-30deg);
  -ms-transform: rotateZ(-30deg);
  transform: rotateZ(-30deg);
  /*color: rgb(80, 139, 136);*/
  color: rgb(237, 71, 50);
  font-weight: bold;
  content: "Fact";
}



</style>
<meta property="og:title" content="웹 개발자를 위한 텍스트 압축"/>
<meta property="og:image" content="story_small.jpg"/>
<meta property="og:description" content="
웹 상의 대부분의 텍스트 데이터는 HTML, JavaScript, CSS 로 구성되어 있습니다. 이런 형식들의 파일에는 손실 압축을 적용할 수 없습니다. 그래서 여러분은 무손실 인코더를 제한적으로 사용하게 되며 이것은 손실 이미지/비디오 압축 코덱에 비해 극적인 압축률을 제공할 수 없습니다. 그렇다면 여러분은 여러분의 웹앱 풋프린트를 어떻게 줄일수 있을까요? 이 글은 웹앱 풋프린트를 줄일수 있는 방법을 안내하여 여러분에게 도움을 드릴 것입니다."/>
{% endblock %}

{% block iscompatible %}
{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block share_image %}
<!--<meta itemprop="image" content="images/your_social_sharing_img.png">-->
{% endblock %}


{% block content %}


<h2 id="toc-introduction">소개</h2>

<p>웹 상의 대부분의 텍스트 데이터는 HTML, JavaScript, CSS 로 구성되어 있습니다. 이런 형식들의 파일에는 손실 압축을 적용할 수 없습니다. 그래서 여러분은 무손실 인코더를 제한적으로 사용하게 되며 이것은 손실 이미지/비디오 압축 코덱에 비해 극적인 압축률을 제공할 수 없습니다. 그렇다면 여러분은 여러분의 웹앱 풋프린트를 어떻게 줄일수 있을까요? 이 글은 웹앱 풋프린트를 줄일수 있는 방법을 안내하여 여러분에게 도움을 드릴 것입니다.

</p>
<center><img src="banner.jpg"  title="Who likes parrots? Everyone." alt="I should take a vacation."></center>
<p>


<h2 id="toc-tldr">TL;DR : 텍스트 데이터 압축 체크리스트</h2>
<p>
  <ol>
    <li>사용자 경험을 <b>모바일 우선</b>으로 생각하세요
      <ol>
        <li>여러분의 페이지 리소스 풋프린트는 어떤것입니까? 여러분을 그것을 줄일수 있습니까?</li>
        <li>여러분의 페이지 로딩 평균시간은 어느 정도 입니까?</li>
      </ol>
    </li>
    <li>모든 콘텐츠는 축소 가능한만큼 축소(minify)해 주세요.
      <ol>
        <li> CSS 와 Javascript Minifier는 강력하며 사용하기 쉽고 기존 빌드 파이프라인에 적용이 쉽습니다.</li>
        <li>여러분의 데이터를 여러분이 할수 있는 만큼 최대한 전처리하세요.</li>
      </ol>
    </li>
    <li>모든 텍스트 리소스에 대해 GZIP 압축을 사용하세요.
      <ol>
        <li>여러분의 서버에 GZIP 압축이 켜져 있는지 확인하세요.</li>
        <li><a href="https://code.google.com/p/zopfli/">Zopfli</a> 또는 <a href="http://www.7-zip.org/">7zip</a>을 사용하는 것으로 오프라인에서 좀 더 압축된 GZIP 데이터를 생성하세요.</li>
      </ol>
    </li>
    <li>만약 더 높은 압축률이 필요하다면 <a href="http://www.bzip.org/">BZIP2</a> and <a href="http://www.7-zip.org/">LZMA</a>와 같은 고성능의 코덱을 사용하세요.</li>
  </ol>

</p>

<h2 id="toc-smallisbig">왜 작은것이 좋은가?</h2>
<p>
모바일은 전세계적으로 연결성이 증가하여 이미 거대한 마켓이 되었습니다. 테크놀로지 회사들은 곧 온라인으로 합류할 5억 인류를 위해 콘텐츠와 데이터를 전달하기 위한 방법을 찾고 있습니다. <a href="http://www.amazon.com/The-New-Digital-Age-Reshaping/dp/1480542288">에릭슈미츠의 “New Digital Age”</a>에서 해당 토픽에 대해 잘 설명하고 있습니다.:
</p>

<p class="notice"><i>
아프리카에는 이미 6.5억 이상, 아시아에는 3억 가까이 되는 모바일 폰 사용자가 있습니다. 대부분의 사람들은 음성통화, 텍스트 메시지 기능을 제공하는 일반 폰을 사용하고 있습니다. 그들 나라에서 데이터 서비스 비용이 종종 엄두를 못 낼 만큼 비싸기 때문입니다. 따라서 웹사용이 가능한 폰 또는 스마트 폰을 살 수 있는 사람들도 비용을 감당할 수 없어 사용하지 못합니다. 이것은 바뀔것입니다. 스마트폰 혁명이 시작될 때 이 인구들에게 큰 이득이 될 것입니다.
</i></p>

<p>
<a href="http://www.cisco.com/en/US/solutions/collateral/ns341/ns525/ns537/ns705/ns827/white_paper_c11-520862.html">Cisco</a> 리포트에 따르면 이것은 새로운 정보가 아닙니다. 모바일 사용자는 <a href="http://www.webperformancetoday.com/2012/02/23/mobile-web-performance-unlimited-data/">2015년까지 예상된 7.88억명</a>에 근접하고 있습니다. 물론, Cisco 같이 큰 회사들에게 이것은 큰 관심사입니다. Cisco는 2012년에 그들의 하드웨어를 통해 <b>월간 597 petabytes</b>의 데이터를 흘려 보냈습니다. 
</p>

<p>
<b>모바일 연결 속도와 단말 성능</b></br>
지난 몇년간 전세계 네트워크 속도는 비약적으로 발전하였습니다. 그러나 이 개선점이 얼마나 수치적으로 혹은 지리적으로 동일하게 적용되었는지 살펴 보는 것이 중요합니다. Google Analytics는 전세계적인 연결성 경향을 보여주는 <a href="http://analytics.blogspot.com/2013/04/is-web-getting-faster.html">환상적인 차트</a>를 가지고 있습니다. 개선점이 균일하지 않다는 것을 쉽게 알수 있습니다. 예를 들어 중국에서 데스크탑의 페이지 로드 평균시간은 <b>8% 증가</b>하였고(느려졌습니다) 모바일에서는 <b>33% 감소</b>하였다(빨라졌습니다). 하지만 여전히 3.5초 이상의 로딩 시간이 필요합니다. <b>15억 3천만 인구가 중 42%가 온라인 상에 있다는 것을 고려 했을 때</b> 이것은 아주 큰 숫자입니다.  
<br><br>
로딩 시간에 대한 사용자 인지과 민감성은 가장 중요한 통계입니다. 우리가 살펴보았듯이 <a href="http://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/">레이턴시는 새로운 웹 성능 병목현상</a>이며 대부분의 국가에서 네트워크의 개선이 하드웨어 문제점과 직접적인 관련이 있다는 것을 알 수 있습니다. 새로운 통신 기지국과 광케이블 건설은 토목 공학적인 악몽이며 엄청난 투자비용을 나타냅니다. 문제점은 일부 기업들이 다른 방법으로 문제점을 해결하기 위해 <a href="http://www.cbc.ca/news/technology/story/2013/06/25/technology-o3bnetworks-satellites-internet.html">수백만 달러의 위성</a>을 개발하는 것과 같이 너무 복잡하다. <b>모바일 네트워크는 <a href="http://en.wikipedia.org/wiki/LTE_(telecommunication)">속도를 증가</a>(천천히, 균일하지 않으며 큰 비용으로)시키기 위한 노력을 계속 할 것입니다.</b> 만약 여러분이 모바일 웹의 속도가 갑자기 빨라지는 것을 기다린다면 여러분은 좀 더 편한 방법을 찾아볼 필요가 있습니다.

</p>

<p>
<b> <i>적게</i> 보내는 것으로 사용자에게 더 <i>많이</i> 주세요.</b></br>
<img src="image03.jpg" style="float:right;margin:15px;">
웹개발자는 가장 빠르고 저렴하며 최고 품질의 사용자 경험을 위해 여러분의 웹사이트를 최적화하는 방법에 대한 최대한의 제어를 할수 있어야 합니다; 가장 좋은 방법 중 하나는 압축입니다.


As a web developer, you have the most control on how to optimize your site for the fastest, cheapest, highest quality experience for your users; One of the best ways to achieve that is with compression.

물론 여러분은 적은 콘텐츠와 적은 범위의 내용으로 모바일 사이트를 만들수도 있습니다. 그러나 사용자는 그런 모바일 사이트를 원하지 않습니다(사이트 모바일 방문자의 1/3은 모바일 사이트와 일반 사이트 중 모든 콘텐츠와 기능을 제공하는 일반 사이트를 선택합니다.). 빠르고 신뢰할 수 있으며 다양한 장치 및 연결에서 크로스 플랫폼 사용자 경험을 줄 수 있는 사이트는 근 미래의 웹을 소유하게 될 것입니다.
</p>



<h2 id="toc-types">압축 알고리즘 종류</h2>
<p>
텍스트 압축 부분은 무손실 압축 알고리즘이으로 구성되는 것이 지배적입니다. (텍스트 기반의 부동소수점 데이터와 같은 특별한 경우를 제외하고). 압축 알고리즘은 소스 스트림에서 정확성과 정보의 손실 없이 직접 복원이 가능해야 하는 것이 일반적입니다. 대부분의 압축 알고리즘 중 인기있는 무손실 코덱으로 <a href="http://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77</a>, <a href="http://en.wikipedia.org/wiki/Huffman_coding">허프만</a>, <a href="http://en.wikipedia.org/wiki/Arithmetic_coding">산술 인코딩</a>이 있습니다. 무손실 압축 알고리즘은 대부분 코덱의 중추입니다. 종종 수 퍼센트의 압축을 더 하기 위해 다른 알고리즘 뒤에 적용되기도 합니다.
</p>
<p>
   
    <figure>
      <table width="100%" border="1">
        <tr><td width="50%"><center>압축 전</center></td><td width="50%"><center>압축 후</center></td></tr>
        <tr><td width="50%"><center>aaaaabbbbbcccddddeeeeffffaaaaabb</center></td><td width="50%"><center>a5b4c2d4e4f4a5bb0</center></td></tr>
      </table>
    
    <figcaption>
    표 1 - 무손실 압축 예제입니다. 연속글자를 연속되는 글자과 연속 길이로 인코딩하였습니다. 우리는 처음 스트림을 적절히 복원 할 수 있습니다. 만약 연속되는 글자의 길이가 2 이하인 경우 변경하지 않고 그대로 두었습니다. 스트림의 마지막에 있는 'bb'를 참조하세요.
    </figcaption>
   </figure>
</p>

<p>
  몇몇 드문 경우, 여러분은 무손실 압축 적용 전, 여러분의 콘텐츠 일부분애 손실 압축을 적용하여 더 많은 절약을 얻을 수 있습니다. 이러한 변형은 처음 소스 상태로 복구될 수 없기 때문에 일반적으로 정보의 손실로 문제가 발생하지 않는 텍스트 기반 데이터 타입에 사용됩니다. 예를 들어 부동 소수점 숫자에서 두자리 소소점까지만 잘라내는 것은 데이터셋에서 받아들일 수 있는 변형일 것입니다.
</p>

<p>
  
  <figure>
      <table width="100%" border="1">
        <tr><td width="50%"><center>압축 전</center></td><td width="50%"><center>압축 후</center></td></tr>
        <tr><td width="50%"><center>0.123, 1.2345, 21.2165, 21.999, 12.123</center></td><td width="50%"><center>0,0,20,20,10</center></td></tr>
      </table>
    <figcaption>
      <i>표 2 - 손실 압축의 예제, 값들이 위치한 10의 최소 배수로 양자화 되었습니다. 이 변형은 되돌릴 수 없습니다.</i>
    </figcaption>
    </figure>
</p>


<h2 id="toc-txtfmt">텍스트 압축 포맷</h2>
<p>
오늘날 텍스트 압축 시스템들은 성공적으로 동작하기 위해 다양한 데이터 변형이 연결되어 처리되고 있습니다. 시스템에서 각 단계의 요점은 다음 단계에서 처리되고 효율적으로 압축할 수 있는 데이터로 변환하는 것입니다. 이 단계들의 합계는 작은 크기의 무손실로 복원 가능한 파일을 생산합니다.  각각 서로 다른 종류의 데이터에 대해 장점과 단점을 가지고 있는 수백가지의 압축 포맷과 시스템이 있습니다. 그들은 (여러 종류의 데이터를 처리하는데) 강력하지 않거나 필요한 압축률을 생산할 수 없기 때문에 여러분은 그들 중 대부분에 대하여 전혀 들어보지 못했습니다. 우리의 목적을 위해 GZIP,BZip2 그리고 7zip과 같은 세가지 유명한 포맷에 대해 살펴 보겠습니다.
</p>

<h2 id="toc-gzip">웹 지원 포맷: GZIP 과 Deflate</h2>
<p>
  오늘날 웹 상에서 <a href="http://en.wikipedia.org/wiki/HTTP_compression">HTTP 압축</a>을 위해 <a href="http://en.wikipedia.org/wiki/DEFLATE">DEFLATE</a>와 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>이 일반적으로 사용됩니다.<br><br>

<a href="http://en.wikipedia.org/wiki/DEFLATE">DEFLATE</a>는 일반적으로 <a href="http://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77</a> 알고리즘과 <a href="http://en.wikipedia.org/wiki/Huffman_coding">허프만</a> 코딩을 사용하여 데이터를 감싸는 매우 인기있는 압축 알고리즘입니다. <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>은 몇몇 흥미로운 블럭화, 휴리스틱(경험적 접근법) 필터링, 헤더와 체크섬과 함께 내부적으로 DEFLATE를 사용하는 파일 포맷입니다. 일반적으로 추가적인 블럭화와 휴리스틱 필터링을 사용한 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>은 DEFLATE만 단독으로 사용한 것보다 더 낳은 압축률을 제공합니다.<br><br>

웹 스택은 배포서버로 실제 압축된 파일들을 전달하기 위해 이 기술들을 반자동으로 사용 할 수 있도록 합니다. (두 알고리즘 모두 압축/해제 속도가 매우 빠릅니다. 이것은 서버사이드 모듈로 그들이 좋은 후보가 되도록 하였습니다.) <a href="http://www.webcodingtech.com/php/gzip-compression.php">PHP</a>, <a href="http://www.askapache.com/htaccess/apache-speed-compression.html">Apache</a> 심지어 <a href="https://developers.google.com/appengine/kb/general#compression">Google App Engine</a> 모두 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>을 지원합니다; 그들은 여러분을 대신하여 파일들을 압축하며 여러분은 트래픽이 전송되는 방식을 설명한 HTTP 헤더 안에 플래그로 설정할 수 있습니다.<br><br>

<a href="http://en.wikipedia.org/wiki/SPDY">SPDY</a>와 같은 차세대 전송 프로토콜과 HTTP2.0은 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>을 사용한 헤더 압축을 지원합니다. 그래서 대부분의 웹 스택은 이 압축 알고리즘에 의존하게 될 것입니다.
</p>


<p>
  <center>
  <table width="100%"><iframe width="560" height="315" src="//www.youtube.com/embed/Mjab_aZsdxw" frameborder="0" allowfullscreen></iframe></table>
</center>
</p>

<p>
<b>더 작은 GZIP 파일 만들기 </b><br>
대부분의 개발자들은 압축되지 않은 콘텐츠를 단순히 업로드 하며 요청시 즉시 데이터를 압축하기 위해 웹서버에 의존합니다. 이것은 대부분 개발자들의 생산성을 크게 향상 시키며 사용하기 쉽습니다. 그러나 대부분의 사람들은 대부분의 서버에 기본 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a> <a href="http://en.wikipedia.org/wiki/Mod_deflate">레벨이 6으로 설정된 것</a>을 모르고 있습니다. 최대 레벨은 9입니다. 이것은 서버가 더 큰 출력 파일의 비용으로 더 빠르게 데이터를 압축하게 합니다.<br><br>

여러분은 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>을 사용하여 여러분의 파일들을 오프라인에서 압축하거나 압축된 파일을 서버에 업로는 하는 것으로 더 나은 압축을 할 수 있습니다. 여러분은 GZIP을 이 과정에서 직접 사용 할 수 있지만 <a href="https://code.google.com/p/zopfli/">Zopfli</a>와 <a href="http://www.7-zip.org/">7zip</a>과 같은 고급 압축은 고급 검색/매칭 알고리즘 그리고 더 나은 패턴 매칭을 위한 더많은 메모리를 활용하는 데이터 구조를 통해 알반적으로 <i>더 작은</i> GZIP 파일을 생성합니다.<br><br>

파일들을 오프라인에서 압축하고 압축된 파일들을 서버로 업로드 하는 것들로 이점을 얻을수 있습니다. 여러분은 미리 압축 된 콘텐츠가 올바르게 전달되기 위해 서버를 구성해야 합니다.(<a href="http://blog.codegrill.org/2009/07/how-to-pre-compress-static-files-in.html">Apache</a>와 <a href="https://forums.aws.amazon.com/message.jspa?messageID=137563">Amazone Web Service</a>에서 설정하기 위한 방법이 여기에 있습니다.) 클라이언트가 여러분의 페이지를 요청할 때 클라이언트 사이드 코드 변경없이 기존처럼 전달 및 압축 해제될 것입니다.
</p>



<h2 id="toc-other">다른 압축 포맷</h2>
<img src="image00.jpg" style="float:left;margin:15px;">
<p>
  <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>이 블록에 대한 유일한 옵션이 아닌 상황에서 만약 웹앱이 큰 블록의 데이터를 전송해야 하거나 자주 전송해야 한다면 여러분은 콘텐츠 사이즈를 줄이는 다른 기술에 투자할 필요가 있습니다. 이 기술들 중 하나는 합리적인 압축 해제 속도로 여러분에게 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>보다 더 나은 압축을 제공하는 자바스크립트 빌드 압축 형식을 사용하는 것을 포함 할수 있습니다.<br><br>

두가지 경쟁적인 압축 포맷들로 <a href="http://www.bzip.org/">BZIP2</a>와 <a href="http://www.7-zip.org/">LZMA</a>가 있습니다. 이것들 모두는 일반적으로 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>보다 더 작은 파일을 생산할 수 있으며 다양한 상황에서도 더 빠르게 압축해제 할 수 있습니다.<br><br>

안타깝게도 이들 두 포맷들은 브라우저에서 네이티브 레벨까지 지원하지 않습니다만 이 인기있는 포맷들은 현재 <a href="https://github.com/cscott/compressjs">자바스크립트로 포팅되어 있으며</a> 이것은 여러분이 이 코덱들로 오프라인에서 데이터를 압축할 수 있으며 클라이언트에서 자바스크립트로 압축해제 할 수 있는 것을 의미합니다.<br><br>

압축해제 시간은 더 느려지게 합니다. 즉, 모든 데이터에 적합하지 않다는 것을 의미합니다. 그러나 개발자의 상호작용과 매우 상세한 웹 앱은 이 방법들을 통해 좋은 결과를 찾을수 있을 것입니다.<br><br>

이 압축 포맷들을 사용할 때 이들 두가지는 압축 경로에서 완전히 다른 단계에 사용합니다. 따라서 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>에 대하여 적절한 비교를 하는 것이 어렵습니다.<br><br>

예를 들면 <a href="http://www.bzip.org/">BZIP2</a> 는 <a href="http://en.wikipedia.org/wiki/Burrows%E2%80%93Wheeler_transform">Burrows Wheeler Transform</a>과 <a href="http://en.wikipedia.org/wiki/Move-to-front_transform">Move To Front</a> Transform으로 만들어 졌습니다. 이 transforms들 모두는 데이터의 실제 사이즈를 줄이기 위해 아무것도 하지 않는 대신에 허프만/산술 인코더에 실제 압축을 수행할 수 있는 방식으로 transform 됩니다. BZIP은 종종 큰 메모리 사용때문에 비판되곤 합니다만(BWT는 네이티브 구현으로 신속하게 메모리를 사용할 수 있습니다.) 지금까지의 비교로는 GZIP보다 쉽고 더 작게 압축할 수 있습니다.<br><br>

<a href="http://www.7-zip.org/">LZMA</a>는 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>의 먼 사촌으로 생각할 수 있습니다. 그들 모두는 통계적 범위 인코딩 시스템을 따르는 인기있는 LZ dictionary 압축에서 시작되었습니다. <a href="http://www.7-zip.org/">LZMA</a>가 <a href="http://en.wikipedia.org/wiki/Gzip">GZIP</a>보다 더 작은 파일들을 생산합니다. 하지만 이것은 LZMA의 고급 LZ matching and windowing 알고리즘 때문입니다.</p>


<h2 id="toc-preprc">더 나은 압축을 위한 텍스트 전처리</h2>
<p>
일반적으로 웹상의 텍스트 압축은 2단계 과정을 갖습니다; 첫번째는 최소화 단계와 이어서 무손실 압축하는 단계입니다.
</p>

<h3 id="toc-minif">최소화</h3>
<p>
첫번째 단계, <b>최소화</b>는 <a href="https://code.google.com/p/v8/">기본 시스템</a>에 의한 처리 없이 가능한 데이터 사이즈 줄이기입니다. 기본적으로 문장구성의 변화 없이 가능한한 필요없는 데이터를 삭제합니다. 예를 들면 자바스크립트 파일의 대부분의 공백은 삭제해도 안전하며 자바스크립트 문법에 변화없이 파일 사이즈를 줄일수 있습니다. 최소화는 일반적으로 <a href="http://gruntjs.com/">빌드 프로세스</a>에서 수동 단계 록은 자동화된 빌드 체인의 부분으로 다뤄집니다.
</p>

<p>
<b>CSS Minifiers</b></br>
선택할수 있는 많은 CSS Minifires가 있습니다.사용할수 있는 몇가지 옵션들을 포함합니다.
<img src="image02.png" style="float:right;margin:15px;">
<ul>
<li><a href="https://github.com/GoalSmashers/clean-css">CleanCSS</a></li>
<li><a href="https://code.google.com/p/cssmin/">CSSMin</a></li>
<li><a href="http://yui.github.io/yuicompressor/">YUI</a></li>
<li><a href="http://csstidy.sourceforge.net/usage.php">CSSTidy</a></li>
<li><a href="https://pypi.python.org/pypi/slimmer/">Slimmer</a></li>
<li><a href="http://www.csscompressor.com/">CSS Compressor</a></li>
</ul>
</p><p>
몇가지 시도해보고 좋을 결과를 주며 최소한의 충돌로 여러분의 워크플로우에 맞는 하나를 선택하세요.<br><br>

이 도구들의 주요 차이점은 그들의 최소화 과정의 깊이에 있다. 예를 들어 간단한 최적화 필터는 테스트에서 초과 공백과 빈 블록을 제거합니다. 더 나은 고급 최적화는 파일에서 hex 양식을 줄이기 위해 "<a href="http://www.w3schools.com/tags/ref_color_tryit.asp?color=AntiqueWhite">AntiqueWhite</a>"를 "<a href="http://www.w3schools.com/tags/ref_color_tryit.asp?hex=FAEBD7">#FAEBD7</a>"로 교환하며 GZIP 압축 향상을 위해 모든 문자를 소문자로 강제로 변환 하는 것을 포함합니다.<br><br>

더 많은 공간을 절약하기 위한 CSS 최소화의 공격적인 방법들은 여러분의 <a href="http://mainroach.blogspot.com/2013/07/css-compression-minifier-roulette.html">CSS rules를 깨뜨릴 위험을 갖고 동작합니다</a>. 따라서 대부분의 개선점이 항상 자동화 될 수는 없으며 개발자들은 파일 사이즈 개선이 위험에 비해  가치가 있는지 결정해야 합니다.<br><br>

사실 CSS코드를 좀 더 효율적으로 작성하기 위해 도움을 주는 <a href="http://sass-lang.com/">CSS 언어</a>의 <a href="http://lesscss.org/">다른 버전</a>을 만드는 새로운 트렌드가 있습니다. 그리고 추가 혜택으로 컴파일러가 더 작은 CSS 코드를 생성할 수 있습니다.<br><br>

</p>




<p>
<b>Javascript Minifiers</b></br>
CSS minifiers와 마찬가지로 한가지로 모든것을 만족시킬수 있는 Javascript minifier는 없습니다. 다시 한번 반복하면 그들은 모두 거의 같은 일을 합니다. 그래서 여러분의 빌드 체인과 여러분의 원하는 기능으로 작업할 수 있는 한가지를 선택해야 합니다. 인기 있는 몇가지:
<img src="image01.jpg" style="float:right;margin:15px;">
<ul>
  <li><a href="https://github.com/mishoo/UglifyJS">UglifyJS</a></li>
  <li><a href="http://www.crockford.com/javascript/jsmin.html">JSMin</a></li>
  <li><a href="http://yui.github.io/yuicompressor/">YUI</a></li>
  <li><a href="http://opensource.perlig.de/rjsmin/">rJSMin</a></li>
  <li><a href="http://dojotoolkit.org/documentation/">Dojo ShrinkSafe</a></li>
  <li><a href="http://aspnet.codeplex.com/releases/view/40584">Ajax Minifier</a></li>
  <li><a href="https://developers.google.com/closure/compiler/">Closure</a></li>
</ul>
</p>
<p>
이들 시스템의 대부분은 <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>의 일종으로 여러분의 자바스크립트를 컴파일하여 작업하며 ASK로부터 좀더 컴팩트한 자바스크립트를 재생성합니다. 공백 최소화, 변수 이름 줄이기, 그리고 짧은 형태로 표현을 다시쓰기를 포함하는 예제 최적화. 예를 들면 foo["bar"] 대신에 foo.bar를 사용합니다.<br><br>

자동화된 minifiers가 잘 수행되고 있지만 <a href="http://www.slideshare.net/ruidlopes/humanpowered-javascript-compression-for-fun-and-gummy-bears">로봇은 어떻게 해야하는지에 대한 생각없으므로</a> 몇가지 고급 최적화가 있습니다. JS 해커의 새로운 세대들은 과거의 자동화된 minification 방법들을 <a href="https://github.com/jed/140bytes/wiki/Byte-saving-techniques">hand-generated minification</a>에 밀어 넣고 있습니다. 이것은 종종 자동화된 도구가 생산할수 있는 어떤것보다 더 작은 파일을 생성하곤 합니다. 물론 만들어 내기 위한 약간의 정신적 고통이 있습니다.<br><br>

</p>


<h3 id="toc-context">Content specific processing</h3>
<p>
While general purpose lossless compression algorithms produce great savings, there’s a common trend of pre-processing your data to get better compression.  The largest wins in most compression systems now come from highly-informed decisions about the format and organization of the information, and exploiting that with grouping and custom compression (this is also called <i>modeling</i>). Most of the time this requires a clear, hard look at your content to determine what types of redundancies you can exploit at a high level. Here are some ideas to get you thinking:</p>

<p>
<ul><li>For text data, some symbols can be removed from the compressed stream, and recovered on the client at a later time (spaces, for example) which can reduce the overall file size, and doesn’t impact client-side performance too much.</li></ul>
</p>
  <figure>
      <table width="100%" border="1">
        <tr><td width="50%"><center>Before</center></td><td width="50%"><center>After</center></td></tr>
        <tr><td width="50%"><center>“1,2,3,4,5,6,7,8,0,2,3,4,2,1,2”</center></td><td width="50%"><center>“123456780234212”0</center></td></tr>
      </table>
    
    <figcaption>
    Figure 3 - An example of removing known, redundant text. We know in this example that all the values are single digit bytes, we can remove the commas and recover them later.
    </figcaption>
   </figure>
<p>
<ul><li>If you’re passing around lots of floating point numbers, <a href="http://en.wikipedia.org/wiki/Vector_quantization">quantizing</a> your values is a great idea, as it will likely reduce the number of unique symbols, and also truncate some precision that is needlessly added to the file.</li></ul>
</p>
  <figure>
      <table width="100%" border="1">
        <tr><td width="50%"><center>Before</center></td><td width="50%"><center>After</center></td></tr>
        <tr><td width="50%"><center>0.123, 1.2345, 21.2165, 21.999, 12.123</center></td><td width="50%"><center>0,0,20,20,10</center></td></tr>
      </table>
    
    <figcap>Figure 4 - An example of lossy compression. Values are quantized to the smallest multiple of 10 they occupy. This transform cannot be reversed.
    </figcaption>
   </figure>
   <br>
<p>
<ul><li>Often times, developers sent around arrays of indexes, which tend to be order-independent. If your index information happens to be a closed interval (ie, all values of X,Y, without any skips) then you could sort your information, and delta encode it for bigger gains.</li></ul>
</p>
  <figure>
      <table width="100%" border="1">
        <tr><td width="50%"><center>Before</center></td><td width="50%"><center>After</center></td></tr>
        <tr><td width="50%"><center>[8,2,1,5,3,7,6,3,2,9,0,4]</center></td><td width="50%"><center>sorted = [0,1,2,3,4,5,6,7,8,9,0]<br>
delta encoded = [0,1,1,1,1,1,1,1,1,1,1]</center></td></tr>
      </table>
    
    <figcaption>
    Figure 5 - An example of sorting and delta encoding. We first sort the data, and then encode it, such that each element is represented as the difference between the previous element. Note how the delta encoded form contains many repetitive symbols.
    </figcaption>
   </figure>
   <br>


<blockquote class="commentary talkinghead talkinghead-cm" id="compressors">
  Recently, compression guru <a href="http://mattmahoney.net/">Matt Mahoney</a> entered a competition to compress <a href="http://maq.sourceforge.net/fastq.shtml">human DNA sequences</a>. His <a href="https://docs.google.com/a/google.com/document/pub?id=1f-8C-ZfCUTEsO-EqvlcTXQ0M5aYM61Aet902dA8QZZk">results were impressive</a>, and generally centered around extraction, modeling and analysis of the content at hand. The ability to extract similar data types from the interleaved stream into homogeneous blocks allows the compression algorithm to take advantage of local information to aid in compression, often allowing the ability to predict future symbols based on several independent data points.
</blockquote>





<p>
It’s quite tricky, and cumbersome to write this type of content-specific compression for arbitrary, mixed-content data files. Luckily for you, some people have already started heading down that path:
<ul>
<li><a href="http://homes.cs.washington.edu/~suciu/XMILL/">XMILL</a> is an <b>XML</b> specific compression system which extracts out heterogenous types of data, groups them together, and runs various compression algorithms on them.
<li>Another fantastic application of this is <a href="http://research.microsoft.com/apps/pubs/?id=120832">JSZap</a>, which will dissect your <b>JavaScript</b> into an Abstract Syntax Tree, and then separate out similar data types into separate streams, compressing each stream individually using an optimal compressor for each one.
<li>You can easily find multiple references in applying this idea to <b>JSON</b> data; once again, you can <a href="http://mainroach.blogspot.com/2013/08/json-compression-transpose-binary.html">preprocess JSON files</a> before passing them off to GZIP in order to produce greater savings.
</ul>

</p>


<h2 id="toc-conclusion">Conclusion</h2>
<p>
Although images take up 60% of most website bandwidth, you can’t ignore that other data block coming from text content. JavaScript files are getting larger, JSON data is sent around every day, and more users are coming online with poor connections. So make sure that every time you push a build of your site, you follow the <b>Text compression checklist</b>:

<ol>
    <li>Think <b>mobile first</b> about user experiences
      <ol>
        <li>What is your page's asset footprint? Can you reduce it?</li>
        <li>How long will it take for users to load your page on average connections?</li>
      </ol>
    </li>
    <li>Minify all content that can be minified.
      <ol>
        <li>CSS and Javascript minifiers are powerful, easy to use, and fit into existing build pipelines.</li>
        <li>Preprocess your data as much as you can.</li>
      </ol>
    </li>
    <li>Use GZIP compression for all text resources.
      <ol>
        <li>Ensure that your server has GZIP compression turned on.</li>
        <li>Generate better compressed GZIP data offline using <a href="https://code.google.com/p/zopfli/">Zopfli</a> or <a href="http://www.7-zip.org/">7zip</a>.</li>
      </ol>
    </li>
    <li>If you need more, embrace advanced codecs like <a href="http://www.bzip.org/">BZIP2</a> and <a href="http://www.7-zip.org/">LZMA</a>.</li>
  </ol>
</p>












{% endblock %}
