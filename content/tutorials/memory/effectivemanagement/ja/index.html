{% extends "tutorial.html" %}

{% block headtitle %}Effectively managing memory at Gmail scale{% endblock %}
{% block pagetitle %}Effectively managing memory at Gmail scale{% endblock %}

{% block head %}
<style>
  figure img { border: 1px solid #ccc; }
</style>
{% endblock %}

{% block content %}


<h2 id="toc-introduction">はじめに</h2>
<p ><span></span>
</p>
<p ><span>JavaScriptは自動メモリ管理であるガベージコレクションの機能を備えますが、アプリケーションが効率的なメモリ管理を全くせずに済む訳ではありません。それどころか、JavaScriptで書かれたアプリケーションは、メモリリークやメモリの肥大化等、ネイティブアプリが抱えるのと同様のメモリ関連の問題や、さらにはガベージコレクションによる処理停止の問題にも対処しなければなりません。Gmailのような大規模なアプリケーションにおいても、あなたのより小さなアプリケーションと同じ問題に直面します。以降の記事では、メモリの問題を特定／切り分け／修正するために、GmailチームがChrome DevToolsをどのように使用したかを学ぶことができます。</span>
</p>

<h2 id="toc-watch-the-movie">Google I/O 2013 セッション</h2>

<p>この記事の内容はGoogle I/O 2013で披露したものと同じです。こちらの動画をご覧ください。</p>
<iframe width="560" height="315" src="http://www.youtube.com/embed/x9Jlu_h_Lyw" frameborder="0" allowfullscreen></iframe>

<h2 id="toc-gmail-problem">Gmailで起きた問題</h2>
<p ><span></span>
</p>
<p ><span>Gmailチームは深刻な問題に直面していました。Gmailのタブが数ギガバイトのメモリを占有し、ノートPCやデスクトップPCの限られたリソースを圧迫している、といった話が方々で聞かれるようになったのです。たいていの場合、話の結末はブラウザーごと落ちてしまうというものでした。CPUの稼働率が100%のまま下がらないだとか、アプリが無反応になるだとか、Chromeの残念なタブ(&ldquo;He&rsquo;s dead, Jim.&rdquo;)が表示されたとか、そういった話です。Gmailチームは途方に暮れ、問題を解決するどころか、どこから手をつければよいかわからない状況でした。どれくらい広範囲に問題が及んでいるのか、検討もつきませんんでしたし、手元のツールは大規模なアプリケーションに対応していませんでした。そこで、GmailチームはChromeチームと共同で、メモリ問題の一時切り分けを行うための技術を開発し、既存のツールを改良し、フィールドからメモリのデータを収集できるようにしました。では、ツールの説明に入る前に、JavaScriptのメモリ管理についておさらいをしましょう。</span>
</p>
<h2 id="toc-basics">メモリ管理の基礎</h2>
<p ><span></span>
</p>
<p ><span>JavaScriptでメモリ管理を効率的に行うには、基本原則を理解していなければいけません。この節では、JavaScriptの基本型、オブジェクトグラフ、一般的なメモリの肥大化やメモリリークについて解説します。JavaScriptにおいて、メモリはグラフに概念化することができます。このことから、</span>
<span>JavaScriptのメモリ管理や</span><span ><a  href="https://developers.google.com/chrome-developer-tools/docs/heap-profiling">ヒーププロファイラ</a></span>
<span>において<a  href="http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%95%E7%90%86%E8%AB%96">グラフ理論</a></span>
<span>が使用されています。</span>
</p>
<h3 id="toc-primitives">基本型</h3>
<p ><span></span>
</p>
<p ><span>JavaScriptは３つの基本型を持ちます。</span>
</p>
<p ><span></span>
</p>
<ol class="c9" start="1">
    <li ><span>Number (例： 4, 3.14159)</span>
    </li>
    <li ><span>Boolean (true もしくは false)</span>
    </li>
    <li ><span>String (&ldquo;Hello World&rdquo;)</span>
    </li>
</ol>
<p ><span></span>
</p>
<p ><span>基本型の値は他の値を参照することはできません。オブジェクトグラフにおいて、これらの値は常にリーフノード、もしくは終端ノードになります。つまり、これらの値は外向きのエッジを持ち得ません。</span>
</p>
<p ><span></span> </p> <p ><span>Object型は唯一のコンテナ型です。JavaScript のオブジェクトは</span><span ><a  href="http://ja.wikipedia.org/wiki/%E9%80%A3%E6%83%B3%E9%85%8D%E5%88%97">連想配列</a></span><span>です。空でないオブジェクトは、他の値(ノード)へのエッジを持つ内部ノードです。</span> </p> <p ><span></span>
</p>
<h4 id="toc-what-about-arrays">配列は？</h4>
<p ><span></span>
</p>
<p ><span>JavaScript の配列は、数値のキーを持つオブジェクトです。実際、JavaScriptエンジンは簡略化のため、Array-likeオブジェクトを内部的に配列として扱います。</span>
</p>
<p ><span></span>
</p>
<h4 id="toc-terminology">用語</h4>
<p ><span></span>
</p>
<ol class="c9" start="1">
    <li ><span >値</span><span>&nbsp;- 基本型、Object型、配列等のインスタンス</span>
    </li>
    <li ><span >変数</span><span>&nbsp;-</span><span>&nbsp;値を参照するときに使う名前</span>
    </li>
    <li ><span >プロパティ</span><span>&nbsp;- オブジェクト内で値を参照するときに使う名前</span>
    </li>
</ol>
<p ><span></span>
</p>
<h3 id="toc-object-graph">オブジェクトグラフ</h3>
<p ><span></span>
</p>
<p ><span>JavaScript 内ではすべての値がオブジェクトグラフに属します。グラフにはルートが存在します。例えば</span><span ><a  href="https://developer.mozilla.org/en-US/docs/DOM/window">window オブジェクト</a></span><span>はルートです。&nbsp;GCのルートの寿命を管理することはできません。なぜなら、ルートはページのロード時にブラウザによって生成／破棄されるからです。グローバル変数は、実のところ</span><span>window</span><span>のプロパティです。</span>
</p>
<p ><span ></span>
</p>
<p >
    <figure>
    <img height="324" src="images/image04.png">
    </figure>
</p>
<h3 id="toc-when-garbage">値はいつガベージになるか？</h3>
<p ><span></span>
</p>
<p ><span>ルートからのパスがなくなった時点で、値はガベージコレクションの対象になります。言い換えると、ルートおよび<a href="http://en.wikipedia.org/wiki/Call_stack">スタック</a>上に存在するすべてのオブジェクトのプロパティと変数から、あらゆる経路を辿っても到達できない場合、そのオブジェクトはガベージと見なされます。</span>
</p>
<p ><span></span>
</p>
<p >
    <figure>
    <img height="290" src="images/image03.png">
    </figure>
</p>
<h3 id="toc-what-is-a-leak">JavaScriptのメモリリークとは？</h3>
<p ><span></span>
</p>
<p ><span>一般的にJavaScript の</span><span>メモリリーク</span><span>は、すでにページのDOMツリーから参照されなくなった</span><span>DOMノード</span><span>が、あるオブジェクトから参照されている場合に発生します。モダンWebブラウザは、うっかりリークを作り込んでしまわないような作りになっていますが、それでもまだリークは容易に発生します。例えば、以下のようにDOMツリーに要素を追加したとしましょう。</span>
</p>
<p ><span></span>
</p>
<pre class="prettyprint">
email.message = document.createElement(&ldquo;div&rdquo;);
displayList.appendChild(email.message);
</pre>
<p ><span>そして、後ほどその要素をdisplayListから削除したとしましょう。</span>
</p>
<p ><span></span>
</p>
<pre class="prettyprint">
displayList.removeAllChildren();
</pre>
<p ><span></span>
</p>
<p ><span>たとえそのDOM要素がページのDOMツリーから参照されなくなったとしても、email オブジェクトが存在し続ける限り、その要素はmessageプロパティにより参照されているので、ガベージコレクションの対象にはなりません。</span>
</p>
<p ><span></span>
</p>
<h3 id="toc-bloat">メモリの肥大化とは？</h3>
<p ><span></span>
</p>
<p ><span>ページのロードに見合ったメモリ量よりも多くのメモリを使用すると、</span><span ><a  href="http://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E8%82%A5%E5%A4%A7%E5%8C%96">肥大化</a></span><span>が発生します。メモリリークも結果的に肥大化を引き起こしますが、それは意図的ではありません。メモリ肥大化のよくある例として、サイズ制限の無いアプリケーションキャッシュが挙げられます。また、ページがロードしたデータ、例えば画像などにより、肥大化が発生することもあります。</span>
</p>
<h3 id="toc-gc">ガベージコレクションとは？</h3>
<p ><span></span>
</p>
<p ><span>ガベージコレクションは JavaScript のメモリ再利用の仕組みです。実行タイミングはブラウザによって決定されます。ひとたび</span><span >ガベージコレクション</span><span>が発生すると、オブジェクトグラフがルートから順に走査される間、ページのスクリプト実行は中断されます。<span><a  href="http://en.wikipedia.org/wiki/Reachability">到達不可能</a></span><span>と判断されたオブジェクトはすべてガベージに分類され、メモリマネージャにより再利用されます。</span>
</p>
<p ><span>&nbsp;</span>
</p>
<h2 id="toc-v8-gc">V8のガベージコレクション詳細</h2>
<p ><span></span>
</p>
<p ><span>ガベージコレクションがどのように発生するか、さらに深く理解するために、V8のガベージコレクタを詳細に見てみましょう。V8は世代別GC方式を採用しています。メモリの領域は新旧２つの世代に分けられます。新世代のメモリ領域では、メモリのアロケーションとガベージコレクションは高速かつ頻繁に実行されます。一方、旧世代のメモリ領域では、逆に低速かつ低頻度で実行されます。</span>
</p>
<h3 id="toc-generational">世代別GC</h3>
<p ><span></span>
</p>
<p ><span>V8は２世代のガベージコレクターを使います。値の年齢とは、その値がアロケートされた時点から今まで何バイトアロケートされたか、で定義されます。実際には、ある値の年齢は、しばしば何回分のガベージコレクションを生き延びたか、によって簡易的に表現されます。そして、ある値が十分古くなれば、旧世代の領域に移されます。</span>
</p>
<p ><span><br>現実には、新たにアロケートされた値はそれほど長く生き続けません。Smalltalkプログラムの研究によると、アロケートされた値のうち、ガベージコレクションを生き延びるのはたかだか7%です。他の研究によると、新たにアロケートされた値のうち、70から90%は新世代のメモリ領域にとどまったままで、旧世代のメモリ領域に移されないことが判明しました。 </span>
</p>
<h3 id="toc-young">新世代GC</h3>
<p ><span></span>
</p>
<p><span>V8の新世代のヒープメモリは</span><span >from</span><span> と </span><span >to</span><span> の２つの領域に隔てられています。メモリはまず、</span><span >to</span><span> の領域からアロケートされます。アロケートはとても高速で、</span>
    <span>to</span><span> 領域がいっぱいになった時点で、ガベージコレクションが起動されます。ガベージコレクタは、まず</span><span >from</span><span> 領域と </span><span >to</span><span>領域をスワップします。古い</span>
        <span>to</span><span>領域 (つまり、今の </span><span >from</span><span> 領域) はスキャンされ、すべての有効な値は </span><span >to</span><span> 領域に移動されるか、もしくは旧世代の領域に移動されます。新世代のガベージコレクションの実行時間は、10 ミリ秒のオーダーです。</span>
</p>
<p ><span></span>
</p>
<p ><span>直感的に理解できると思いますが、アプリケーションがメモリアロケートを繰り返すと、いずれ</span><span >to</span><span> 領域が枯渇してGCが発生します。特にゲーム開発者は注意してください。(60 fps を実現するために) 16ミリ秒のフレーム時間を保証するには、あなたのアプリケーションは一回たりともメモリをアロケートすることはできません。なぜなら、一回の新世代ガベージコレクションでフレーム時間のほとんどを使ってしまうからです。</span>
</p>
<p ><span></span>
</p>
<p >
    <figure>
    <img height="381" src="images/image01.png">
    </figure>
</p>
<h3 id="toc-old-generation">旧世代GC</h3>
<p ><span></span>
</p>
<p ><span>V8の旧世代GCは</span><span ><a  href="http://en.wikipedia.org/wiki/Mark-compact_algorithm">マークコンパクト アルゴリズム</a></span><span>を採用しています。旧世代のメモリ領域は、値が新世代のメモリ領域から旧世代の領域に移された時点で、アロケートされます。旧領域のメモリ領域でガベージコレクションが実行されると、必ず新世代のGCも実行されます。ひとたび処理が走ると、アプリケーションは秒のオーダーで実行が止まります。現実には、旧世代のGCはそれほど頻繁に発生しないので、これだけ処理時間がかかっても許容されるのです。</span>
</p>
<p ><span></span>
</p>
<h3 id="toc-v8-gc-summary">V8のGCまとめ</h3>
<p ><span></span>
</p>
<p ><span>ガベージコレクションによる自動メモリ管理は、開発者の生産性という点ではすばらしいですが、値をアロケートするたびにGC発生のリミットに近づきます。GCによる処理停止は、アプリケーションの印象を損ないます。以上で、JavaScriptがどのようにメモリを管理するか、学ぶことが出来たので、ご自身のアプリケーションにおいて、正しい選択ができるようになると思います。</span>
</p>
<h2 id="toc-fixing-gmail">Gmailの修正内容</h2>
<p ><span></span>
</p>
<p ><span>Over the past year, numerous features and bug fixes have made their way into the Chrome DevTools making them more powerful than ever. In addition, the browser itself made a key change to the performance.memory API making it possible for Gmail and any other application to collect memory statistics from the field. Armed with these awesome tools, w</span><span>hat once seemed like an impossible task soon became an exciting game of tracking down culprits.</span>
</p>
<h3 id="toc-tools-techniques">Tools and Techniques</h3>
<h4 id="toc-performance-memory">Field Data and performance.memory API</h4>
<p ><span></span>
</p>
<p ><span>As of Chrome 22, the </span><span ><a  href="http://docs.webplatform.org/wiki/apis/timing/properties/memory">performance.memory API</a></span><span>&nbsp;is enabled by default. &nbsp;For long-running applications like Gmail, data from real users is invaluable. This information allows us to distinguish between power users-- those who spend 8-16 hours a day on Gmail, receiving hundreds of messages a day-- from more average users who spend a few minutes a day in Gmail, receiving a dozen or so messages a week. &nbsp;</span>
</p>
<p ><span></span>
</p>
<p ><span>This API returns three pieces of data:</span>
</p>
<p ><span></span>
</p>
<ol class="c9" start="1">
    <li ><span >jsHeapSizeLimit</span><span>&nbsp;- The amount of memory (in bytes) that the JavaScript heap is limited to.</span>
    </li>
    <li ><span >totalJSHeapSize</span><span>&nbsp;- The amount of memory (in bytes) that the JavaScript heap has allocated including free space.</span>
    </li>
    <li ><span >usedJSHeapSize</span><span>&nbsp;- The amount of memory (in bytes) currently being used.</span>
    </li>
</ol>
<p ><span></span>
</p>
<p ><span>One thing to keep in mind is that the API returns memory values for the entire Chrome process. Although it is not the default mode, under certain circumstances, Chrome may open multiple tabs in the same renderer process. This means that the values returned by performance.memory may contain the memory footprint of other browser tabs in addition to the one containing your app.</span>
</p>
<h4 id="toc-memory-scale">Measuring Memory At Scale</h4>
<p ><span></span>
</p>
<p ><span>Gmail instrumented their JavaScript to use the performance.memory API to collect memory information approximately once every 30 minutes. &nbsp;Because many Gmail users leave the app up for days at a time, the team was able to track memory growth over time as well as overall memory footprint statistics. Within a few days of instrumenting Gmail to collect memory information from a random sampling of users, the team had enough data to understand how widespread the memory problems were among average users. They set a baseline and used the stream of incoming data to track progress toward the goal of reducing memory consumption. Eventually this data would also be used to catch any memory regressions.</span>
</p>
<p ><span></span>
</p>
<p ><span>Beyond tracking purposes, the field measurements also provide a keen insight into the correlation between memory footprint and application performance. &nbsp;Contrary to the popular belief that &ldquo;more memory results in better performance&rdquo;, the Gmail team found that the larger the memory footprint, the longer latencies were for common Gmail actions. Armed with this revelation, they were more motivated than ever to rein in their memory consumption.</span>
</p>
<p ><span></span>
</p>
<p >
    <figure>
    <img height="186" src="images/image05.png">
    </figure>
</p>
<h4 id="toc-identify-memory">Identifying a Memory Problem with the DevTools Timeline</h4>
<p ><span></span>
</p>
<p ><span>The first step in solving any performance problem is to prove that the problem exists, create a reproducible test, and take a baseline measurement of the problem. Without a reproducible program, you cannot reliably measure the problem. Without a baseline measurement you don&rsquo;t know by how much you&rsquo;ve improved performance.</span>
</p>
<p ><span></span>
</p>
<p ><span>The DevTools </span><span>Timeline panel </span><span>is an ideal candidate for proving that the problem exists. It </span><span>gives a complete overview of where time is spent when loading and interacting with your web app or page. All events, from loading resources to parsing JavaScript, calculating styles, garbage collection pauses, and repainting are plotted on a timeline. For the purposes of investigating memory issues, the Timeline panel also has a Memory mode which tracks total allocated memory, number of DOM nodes, number of window objects, and the number of event listeners allocated.</span>
</p>
<h4 id="toc-problem-exists">Proving a problem exists</h4>
<p ><span></span>
</p>
<p ><span>Start by identifying a sequence of actions you suspect to be leaking memory. Start recording the timeline, and perform the sequence of actions. &nbsp;Use the trash can button at the bottom to force a full garbage collection. &nbsp;If, after a few iterations, you see a </span>
    <span
    ><a  href="http://en.wikipedia.org/wiki/Sawtooth_wave">sawtooth</a>
        </span><span>&nbsp;shaped graph, you are allocating lots of shortly lived objects. But if the sequence of actions is not expected to result in any retained memory, and the DOM node count does not drop down back to the baseline where you began, you have good reason to suspect there is a leak. </span>
</p>
<p >
    <figure>
    <img height="347" src="images/image02.png">
    </figure>
</p>
<p ><span></span>
</p>
<p ><span>Once you&rsquo;ve confirmed that the problem exists, you can get help identifying the source of the problem from the DevTools Heap Profiler.</span>
</p>
<p ><span></span>
</p>
<h4 >Finding Memory Leaks with the DevTools Heap Profiler</h4>
<p ><span></span>
</p>
<p ><span>The Profiler panel provides both a CPU profiler and a Heap profiler. Heap profiling works by taking a snapshot of the object graph. Before a snapshot is taken both the young and old generations are garbage collected. In other words, you will only see values which were alive when the snapshot was taken.</span>
</p>
<p ><span></span>
</p>
<p ><span>There is too much functionality in the the Heap profiler to cover sufficiently in this article, but </span><span ><a  href="https://developers.google.com/chrome-developer-tools/docs/heap-profiling">detailed documentation</a></span><span>&nbsp;can be found on the Google Developers site</span><span>. We&rsquo;ll focus here on the all new Object Tracker, available now via an experiment on the latest Chrome builds. &nbsp;To enable the Object Tracker:</span>
</p>
<ol class="c2" start="1">
    <li ><span>Make sure you have the latest </span><span ><a  href="https://www.google.com/intl/en/chrome/browser/canary.html">Chrome Canary</a></span><span>. </span>
    </li>
    <li ><span>Navigate to about:flags, and make sure &ldquo;Enable Developer Tools experiments&rdquo; is enabled. You will need to restart Chrome to activate the experiments. &nbsp;</span>
    </li>
    <li ><span>Open the Developer Tools and click on the gear icon in the lower right. &nbsp;Find the Experiments item in the menu on the left, and check the box labeled &ldquo;Enable heap objects tracking profile type&rdquo;. &nbsp;You will need to close and reopen the DevTools to make this change take effect.</span>
    </li>
    <li ><span>Now, when you open the Profiler panel, you should see a fourth profile type option, called &ldquo;Track Allocations&rdquo;.</span>
    </li>
</ol>
<h4 id="toc-object-tracker">Using the Object Tracker</h4>
<p ><span></span>
</p>
<p ><span>The Object Tracker combines the detailed snapshot information of the Heap Profiler with the incremental updating and tracking of the Timeline panel. Start a recording, perform a sequence of actions, then stop the recording for analysis. The Object Tracker takes heap snapshots periodically throughout the recording (as frequently as every 50 ms!) and one final snapshot at the end of the recording.</span>
</p>
<p ><span></span>
</p>
<p >
    <figure>
    <img height="339" src="images/image00.png">
    </figure>
</p>
<p ><span>The bars at the top indicate when new objects are found in the heap. &nbsp;The height of each bar corresponds to the size of the recently allocated objects, and the color of the bars indicate whether or not those objects are still live in the final heap snapshot: blue bars indicate objects that are still live at the end of the timeline, gray bars indicate objects that were allocated during the timeline, but have since been garbage collected.</span>
</p>
<p ><span></span>
</p>
<p ><span>In the example above, an action was performed 10 times. &nbsp;The sample program caches five objects, so the last five blue bars are expected. &nbsp;But the leftmost blue bar indicates a potential problem. You can then use the sliders in the timeline above to zoom in on that particular snapshot and see the objects that were recently allocated at that point. &nbsp;Clicking on a specific object in the heap will show its retaining tree in the bottom portion of the heap snapshot. Examining the retaining path to the object should give you enough information to understand why the object was not collected, and you can make the necessary code changes to remove the unnecessary reference.</span>
</p>
<h2 id="toc-resolving-crisis">Resolving Gmail's Memory Crisis</h2>
<p ><span></span>
</p>
<p ><span>By using the tools and techniques discussed above, the Gmail team was able to identify a few categories of bugs: &nbsp;unbounded caches, infinitely growing arrays of callbacks waiting for something to happen that never actually happens, and event listeners unintentionally retaining their targets. By fixing these issues, the overall memory usage of Gmail was dramatically reduced. Users in the 99% percent used 80% less memory than before and the memory consumption of the median users dropped by nearly 50%.</span>
</p>
<p ><span></span>
</p>
<p >
    <figure>
    <img height="350" src="images/image06.png">
    </figure>
</p>
<p ><span></span>
</p>
<p ><span></span>
</p>
<p ><span>Because Gmail used less memory the GC pause latency was reduced, increasing the overall user experience.</span>
</p>
<p ><span></span>
</p>
<p ><span>Also of note, with the Gmail team collecting statistics on memory usage, they were able to uncover garbage collection regressions inside Chrome. Specifically, two fragmentation bugs were discovered when Gmail&rsquo;s memory data began showing a dramatic increase in the gap between total memory allocated and live memory.</span>
</p>
<p ><span></span>
</p>
<h2 id="toc-call-to-action">チェックリスト</h2>
<p ><span></span>
</p>
<p ><span>Ask yourself these questions:<br></span>
</p>
<ol class="c9" start="1">
    <li class="c3 c6"><span>How much memory is my app using?</span>
    </li>
</ol>
<p ><span></span>
</p>
<p ><span>It&rsquo;s possible that you are using too much memory which contrary to popular belief has a net negative on overall application performance. It&rsquo;s hard to know exactly what the right number is, but, be sure to verify that any extra caching your page is using has a measurable performance impact.</span>
</p>
<p ><span></span>
</p>
<ol class="c9" start="1">
    <li ><span>Is my page leak free?</span>
    </li>
</ol>
<p ><span></span>
</p>
<p ><span>If your page has memory leaks it can not only impact your page's performance but other tabs as well. Use the object tracker to help narrow in on any leaks.</span>
</p>
<p ><span></span>
</p>
<ol class="c9" start="1">
    <li ><span>How frequently is my page GCing?</span>
    </li>
</ol>
<p ><span></span>
</p>
<p ><span>You can see any GC pause using </span><span ><a  href="https://developers.google.com/chrome-developer-tools/docs/timeline">Timeline panel</a></span><span>&nbsp;in </span><span ><a  href="https://developers.google.com/chrome-developer-tools/">Chrome Developer Tools</a></span><span>. If your page is GCing frequently, chances are you are allocating too frequently, churning through your young generation memory. </span>
</p>
<p ><span></span>
</p>
<h2 id="toc-conslusion">おわりに</h2>
<p ><span></span>
</p>
<p ><span>We started off in a crisis. Covered the core basics of memory management in JavaScript and V8 in particular. You learned how to use the tools, including the new object tracker feature available in the latest builds of Chrome. The Gmail team, armed with this knowledge, solved their memory usage problem and saw improved performance. You can do the same with your web apps!</span>
</p>

{% endblock %}
